Index

Index
Class 1 - Array and Sorting Algorithms
Selection Sort
Merge Sort
Quick Sort
Move 0s To The End I
Rainbow Sort
Class 2 - Recursion I and Binary Search
Fibonacci Number
a To the Power of b
Classical Binary Search
Binary Search In Sorted 2D Array I
First Occurrence
Last Occurrence
Closest Number In Sorted Array
K Closest In Sorted Array
Search In Unknown Sized Sorted Array
Class 3 - Queue, Stack & Linked List
Implement Queue By Two Stacks
Stack With min()
Sort Numbers In Three Stacks
Reverse Linked List
Find Middle Node Of Linked List
Check If Linked List Has Cycle
Insert In Sorted Linked List
Merge Two Sorted Linked List
Reorder Linked List
Partition Linked List
Class 4 - Binary Tree & Binary Search Tree
Binary Tree Pre-order Iterative Traversal
Binary Tree In-order Iterative Traversal
Binary Tree Post-order Iterative Traversal
Check If Binary Tree Is Balanced
Check If Binary Tree Is Symmetric
Tweaked Identical Binary Trees
Is Binary Search Tree Or Not
Get Keys In Binary Search Tree In Given Range
Class 5 - Heap & Graph Search Algorithm I (BFS)
K Smallest In Unsorted Array
Get Keys In Binary Tree Layer By Layer
Bipartite
Check If Binary Tree Is Complete
Kth Smallest Number In Sorted Matrix
Class 6 - Graph Search Algorithm II (DFS)
All Subsets I
All Valid Permutations Of Parentheses I
Combinations Of Coins
All Permutations I
Class 7 - HashTable & String 1
Top K Frequent Words
Missing Number I
Common Numbers Of Two Sorted Arrays
Remove Certain Characters
Remove All Leading/Trailing/Duplicate Space Characters
Remove Adjacent Repeated Characters I
Remove Adjacent Repeated Characters IV
Determine If One String Is Another’s Substring
Class 8 - String II
Reverse String
Reverse Words In Sentence
Right Shift By N Characters
String Replace
String Shuffling
All Permutations II(with duplicate characters)
Decompress String II
Longest Substring With Only Unique Characters
Find All Anagrams Of Short String In A Long String
Class 10 - Recursion II
N Queens
Spiral Order Traverse I
Spiral Order Traverse II
Spiral Order Generate I
Spiral Order Generate II
Reverse Linked List In Pairs
Abbreviation Matching
Store Number Of Nodes In Left Subtree
Given a binary tree, find the node with the max difference in the total number descendents in its left subtree and right subtree
Lowest Common Ancestor I
Class 11 - Bit Representation and Bit Operation
Determine If A Number Is Power Of 2
Number Of Different Bits
All Unique Characters II
Hexadecimal Representation
Reverse Bits
Class 12 - Dynamic Programming I
Longest Ascending Subarray
Max Product Of Cutting Rope
Array Hopper I
Class 13 - Dynamic Programming II
Array Hopper II
Largest Subarray Sum
Dictionary Word
Edit Distance
Largest Square Of “1” s
Class 15 - Dynamic Programming III
Longest Consecutive 1s
Largest Cross With All “1”s
Largest X With All “1”s
Given a matrix where every element is either ‘0’ or ‘1’, find the largest subsquare surrounded by ‘1’.
Largest Submatrix Sum
Class 16 - Probability, Sampling, Randomization
Shuffle
Reservoir Sampling
Reservoir Sampling With K Samples
Random7 Using Random5
Random1000 Using Random5
Median Tracker Of Data Flow
95th Percentile
Class 18 - 加强练习 I
Array Deduplication I(sorted array, duplicate element only retain one)
Array Deduplication II(sorted array, duplicate element only retain two)
Array Deduplication III(sorted array, duplicate element not retain any)
Array Deduplication IV(unsorted array, repeatedly deduplication)
Move 0s To The End II
Largest And Smallest
Largest And Second Largest
Rotate Matrix By 90 Degree Clockwise
Zig-Zag Order Print Binary Tree
Lowest Common Ancestor Of K Nodes
Lowest Common Ancestor(with parent pointer)
Sort In Specified Order
Class 20 - Midterm II
Maximum Path Sum Binary Tree I(from one leaf node to another leaf)
Min Cuts Of Palindrome Partitions
Valid If Blocks
Class 21 - 强化练习 II
Deep Copy Linked List With Random Pointer
Deep Copy Of Graph(with possible cycles)
Merge K Sorted Arrays
Merge K Sorted Lists
Closest Number In Binary Search Tree
Binary Search Tree Largest Number Smaller Than Target
Binary Search Tree Delete
Cutting Wood I
Merge Stones
Class 22 - 强化练习 III
Max Path Sum Binary Tree II(path from any node to any node)
Max Path Sum Binary Tree(path from leaf to root)
Binary Tree Path Sum To Target(the two nodes can be the same node and they can only be on the path from root to one of the leaf nodes)
Max Path Sum Binary Tree III(the two nodes can be the same node and they can only be on the path from root to one of the leaf nodes)
Reconstruct Binary Tree With Preorder And Inorder
Reconstruct Binary Search Tree With Postorder
Reconstruct Binary Tree With Levelorder And Inorder
Class 24 - 强化练习 IV
Reverse Binary Tree Upside Down
All Valid Permutations Of Parentheses II(L pairs of (), M pairs of [], N pairs of{})
All Subsequences Of Sorted String(All Subsets II)
2 Sum
2 Sum All Pair I
2 Sum All Pair II
3 Sum
4 Sum
Common Elements In Three Sorted Arrays
Class 25 - 加强练习 V
Largest Product of Length
Kth Smallest With Only 3,5,7 As Factors
Kth Closest Point To <0,0,0>
Place To Put Chair I
Largest Rectangle In Histogram
Max Water Trapped I
Max Water Trapped II
Class 27 - 加强练习 VI
Kth Smallest In Two Sorted Arrays
Maximum Values Of Size K Sliding Windows
Implement LRU Cache
First Non-Repeating Character In Stream
Majority Number I
Interleave Strings
Class 28 - 加强练习 VII
Longest Common Substring
Longest Common Subsequence
Longest Ascending Subsequence
Most Points On A Line
Largest Set Of Points With Positive Slopes
Generate Random Maze
Class 99
Get Count Array
Largest Sum Of Valid Numbers


Class 1 - Array and Sorting Algorithms
Selection Sort
public class SelectionSort {
  public int[] selectionSort(int[] array) {
    // check null before any other things.
    // check other conditions - empty array… etc.
    if (array == null || array.length <= 1) {
      return array;
    }
    for (int i = 0; i < array.length - 1; i++) {
      int min = i;
      // find the min element in the subarray of (i, array.length - 1)
      for (int j = i + 1; j < array.length; j++) {
        if (array[j] < array[min]) {
          min = j;
        }
      }
      swap(array, i, min);
    }
    return array;
  }

  public void swap(int[] array, int left, int right) {
    int temp = array[left];
    array[left] = array[right];
    array[right] = temp;
  }

  public static void main(String[] args) {
    SelectionSort solution = new SelectionSort();

    // test cases to cover all the possible situations.
    int[] array = null;
    array = solution.selectionSort(array);
    System.out.println(Arrays.toString(array));

    array = new int[0];
    array = solution.selectionSort(array);
    System.out.println(Arrays.toString(array));

    array = new int[] { 1, 2, 3, 4 };
    array = solution.selectionSort(array);
    System.out.println(Arrays.toString(array));

    array = new int[] { 4, 3, 2, 1 };
    array = solution.selectionSort(array);
    System.out.println(Arrays.toString(array));

    array = new int[] { 2, 4, 1, 5, 3 };
    array = solution.selectionSort(array);
    System.out.println(Arrays.toString(array));
  }
}

Merge Sort
public class MergeSort {
  public int[] mergeSort(int[] array) {
    // check null array first.
    if (array == null) {
      return array;
    }
    // allocate helper array to help merge step,
    // so that we guarantee no more than O(n) space is used.
    // The space complexity is O(n) in this case.
    int[] helper = new int[array.length];
    mergeSort(array, helper, 0, array.length - 1);
    return array;
  }

  private void mergeSort(int[] array, int[] helper, int left, int right) {
    if (left >= right) {
      return;
    }
    int mid = left + (right - left) / 2;
    mergeSort(array, helper, left, mid);
    mergeSort(array, helper, mid + 1, right);
    merge(array, helper, left, mid, right);
  }

  private void merge(int[] array, int[] helper, int left, int mid, int right) {
    // copy the content to helper array and we will merge from the
    // helper array.
    for (int i = left; i <= right; i++) {
      helper[i] = array[i];
    }
    int leftIndex = left;
    int rightIndex = mid + 1;
    while (leftIndex <= mid && rightIndex <= right) {
      if (helper[leftIndex] <= helper[rightIndex]) {
        array[left++] = helper[leftIndex++];
      } else {
        array[left++] = helper[rightIndex++];
      }
    }
    // if we still have some elements at left side, we need to copy them
    while (leftIndex <= mid) {
      array[left++] = helper[leftIndex++];
    }
    // if there are some elements at right side, we do not need to copy them
    // because they are already in their position.
  }

  public static void main(String[] args) {
    MergeSort solution = new MergeSort();

    // test cases to cover possible situations.
    int[] array = null;
    array = solution.mergeSort(array);
    System.out.println(Arrays.toString(array));

    array = new int[0];
    array = solution.mergeSort(array);
    System.out.println(Arrays.toString(array));

    array = new int[] { 1, 2, 3, 4 };
    array = solution.mergeSort(array);
    System.out.println(Arrays.toString(array));

    array = new int[] { 4, 3, 2, 1 };
    array = solution.mergeSort(array);
    System.out.println(Arrays.toString(array));

    array = new int[] { 2, 4, 1, 5, 3 };
    array = solution.mergeSort(array);
    System.out.println(Arrays.toString(array));
  }
}

Quick Sort
public class QuickSort {
  public int[] quickSort(int[] array) {
    // check null first.
    if (array == null) {
      return array;
    }
    quickSort(array, 0, array.length - 1);
    return array;
  }

  public void quickSort(int[] array, int left, int right) {
    if (left >= right) {
      return;
    }
    // define a pivot and use the pivot to partition the array.
    int pivotPos = partition(array, left, right);
    // pivot is already at its position, when we do the recursive call on
    // the two partitions, pivot should not be included in any of them.
    quickSort(array, left, pivotPos - 1);
    quickSort(array, pivotPos + 1, right);
  }

  private int partition(int[] array, int left, int right) {
    int pivotIndex = pivotIndex(left, right);
    int pivot = array[pivotIndex];
    // swap the pivot element to the rightmost position first
    swap(array, pivotIndex, right);
    int leftBound = left;
    int rightBound = right - 1;
    while (leftBound <= rightBound) {
      if (array[leftBound] < pivot) {
        leftBound++;
      } else if (array[rightBound] >= pivot) {
        rightBound--;
      } else {
        swap(array, leftBound++, rightBound--);
      }
    }
    // swap back the pivot element.
    swap(array, leftBound, right);
    return leftBound;
  }

  // this is one of the ways defining the pivot,
  // pick random element in the range of [left, right].
  private int pivotIndex(int left, int right) {
    return left + (int) (Math.random() * (right - left + 1));
  }

  private void swap(int[] array, int left, int right) {
    int temp = array[left];
    array[left] = array[right];
    array[right] = temp;
  }

  public static void main(String[] args) {
    QuickSort solution = new QuickSort();

    int[] array = null;
    array = solution.quickSort(array);
    System.out.println(Arrays.toString(array));

    array = new int[0];
    array = solution.quickSort(array);
    System.out.println(Arrays.toString(array));

    array = new int[] { 1, 2, 3, 4 };
    array = solution.quickSort(array);
    System.out.println(Arrays.toString(array));

    array = new int[] { 4, 3, 2, 1 };
    array = solution.quickSort(array);
    System.out.println(Arrays.toString(array));

    array = new int[] { 2, 5, 3, 1, 4 };
    array = solution.quickSort(array);
    System.out.println(Arrays.toString(array));
  }
}

Move 0s To The End I
/**
 * Move 0s to the right end of the array, no need to keep the relative 
 * order of the elements in the original array.
 */
public class MoveZeroI {
  public int[] moveZero(int[] array) {
    if (array == null || array.length <= 1) {
      return array;
    }
    int left = 0;
    int right = array.length - 1;
    while (left <= right) {
      if (array[left] != 0) {
        left++;
      } else if (array[right] == 0) {
        right--;
      } else {
        swap(array, left++, right--);
      }
    }
    return array;
  }

  private void swap(int[] array, int a, int b) {
    int tmp = array[a];
    array[a] = array[b];
    array[b] = tmp;
  }
}

Rainbow Sort
/**
 * Assumption:
 * 1).we have three colors denoted as -1, 0, 1 and all the elements in the
 *    array are valid.
 */
public class RainbowSort {
  public int[] rainbowSort(int[] array) {
    if (array == null || array.length <= 1) {
      return array;
    }
    // three bounds:
    // 1. the left side of neg is -1 (exclusive of neg).
    // 2. the right side of one is 1 (exclusive of one).
    // 3. the part between neg and zero is 0 (exclusive of zero).
    // 4. between zero and one is to be discovered. (inclusive of both).
    int neg = 0;
    int one = array.length - 1;
    int zero = 0;
    while (zero <= one) {
      if (array[zero] == -1) {
        swap(array, neg++, zero++);
      } else if (array[zero] == 0) {
        zero++;
      } else {
        swap(array, zero, one--);
      }
    }
    return array;
  }

  private void swap(int[] array, int a, int b) {
    int tmp = array[a];
    array[a] = array[b];
    array[b] = tmp;
  }
}

Back To Index

Class 2 - Recursion I and Binary Search
Fibonacci Number
public class FibonacciNumber {
  // Method 1: recursion, this method will timeout on laicode.com
  public long fibonacci(int K) {
    if (K <= 0) {
      return 0;
    }
    if (K == 1) {
      return 1;
    }
    return fibonacci(K - 1) + fibonacci(K - 2);
  }
  
  // Method 2: dp solution with O(n) space.
  public long fibonacciI(int K) {
    if (K <= 0) {
      return 0;
    }
    long[] array = new long[K + 1];
    array[1] = 1;
    for (int i = 2; i <= K; i++) {
      array[i] = array[i - 2] + array[i - 1];
    }
    return array[K];
  }
  
  // Method 3: dp solution with O(1) space.
  public long fibonacciII(int K) {
    long a = 0;
    long b = 1;
    if (K <= 0) {
      return a;
    }
    while (K > 1) {
      long temp = a + b;
      a = b;
      b = temp;
      K--;
    }
    return b;
  }

  // Method 4: O(logn) solution using matrix multiplication.
  // M = {{1, 1}, {1, 0}} = {{f(2), f(1)}, {f(1), f{0}}}
  // fibo(K) = (M ^ K)[0][0]
  public static final long[][] SEED = { { 1L, 1L }, { 1L, 0L } };

  public long fibonacciIII(int K) {
    if (K <= 0) {
      return 0;
    }
    if (K == 1) {
      return 1;
    }
    long[][] matrix = { { 1L, 1L }, { 1L, 0L } };
    pow(matrix, K - 1);
    return matrix[0][0];
  }

  // calculate matrix ^ pow, and use the result to update matrix value.
  private void pow(long[][] matrix, int pow) {
    if (pow == 1) {
      return;
    }
    pow(matrix, pow / 2);
    multiply(matrix, matrix);
    if (pow % 2 != 0) {
      multiply(matrix, SEED);
    }
  }

  // matrix multiplication and the result is updated to matrix itself.
  private void multiply(long[][] matrix, long[][] multiplier) {
    long topLeft = matrix[0][0] * multiplier[0][0] + matrix[0][1] * multiplier[1][0];
    long topRight = matrix[0][0] * multiplier[0][1] + matrix[0][1] * multiplier[1][1];
    long bottomLeft = matrix[1][0] * multiplier[0][0] + matrix[1][1] * multiplier[1][0];
    long bottomRight = matrix[1][0] * multiplier[0][1] + matrix[1][1] * multiplier[1][1];
    matrix[0][0] = topLeft;
    matrix[0][1] = topRight;
    matrix[1][0] = bottomLeft;
    matrix[1][1] = bottomRight;
  }
}

a To the Power of b
public class Power {
  // Assumption: b >= 0.
  public long power(int a, int b) {
    if (b == 0) {
      return 1;
    }
    if (a == 0) {
      return 0;
    }
    long half = power(a, b / 2);
    return b % 2 == 0 ? half * half : half * half * a;
  }
}

Classical Binary Search
public class ClassicalBinarySearch {
  public int binarySearch(int[] array, int target) {
    if (array == null || array.length == 0) {
      return -1;
    }
    int left = 0;
    int right = array.length - 1;
    while (left <= right) {
      int mid = left + (right - left) / 2;
      if (array[mid] == target) {
        return mid;
      } else if (array[mid] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    return -1;
  }
}

Binary Search In Sorted 2D Array I
/**
 * Search in sorted matrix, each row of the matrix is sorted in ascending order,
 * and the first element of the row is equals to or larger than the last element
 * of the previous row.
 * 
 * Return the position if the target is found, otherwise return {-1, -1}.
 */
public class SearchInSortedMatrixI {
  // Assumptions: matrix is not null, and has size N * M where N >= 0 and M >= 0.
  // return {-1, -1} if not found.
  // Method 1: find row first then find col.
  public int[] searchI(int[][] matrix, int target) {
    int[] result = new int[] { -1, -1 };
    if (matrix.length == 0 || matrix[0].length == 0) {
      return result;
    }
    // Find the possible row location for target.
    int row = findRow(matrix, 0, matrix.length - 1, target);
    if (row == -1) {
      return result;
    }
    // Find the possible col location in the row for target.
    int col = findCol(matrix[row], 0, matrix[row].length - 1, target);
    if (col == -1) {
      return result;
    }
    result[0] = row;
    result[1] = col;
    return result;
  }

  // Find the largest row with first element <= target.
  private int findRow(int[][] matrix, int up, int down, int target) {
    while (up <= down) {
      int mid = up + (down - up) / 2;
      if (matrix[mid][0] > target) {
        down = mid - 1;
      } else {
        up = mid + 1;
      }
    }
    return down;
  }

  // Classical binary search to find the col on the row.
  private int findCol(int[] array, int left, int right, int target) {
    while (left <= right) {
      int mid = left + (right - left) / 2;
      if (array[mid] == target) {
        return mid;
      } else if (array[mid] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    return -1;
  }

  // Method 2: convert the 2D array to 1D array and do binary search.
  public int[] search(int[][] matrix, int target) {
    if (matrix.length == 0 || matrix[0].length == 0) {
      return new int[] { -1, -1 };
    }
    int rows = matrix.length;
    int cols = matrix[0].length;
    int left = 0;
    // convert the 2D array to 1D array with rows * cols elements.
    int right = rows * cols - 1;
    while (left <= right) {
      int mid = left + (right - left) / 2;
      // convert the position in 1D array back to row and col in 2D array.
      int row = mid / cols;
      int col = mid % cols;
      if (matrix[row][col] == target) {
        return new int[] { row, col };
      } else if (matrix[row][col] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    return new int[] { -1, -1 };
  }
}

First Occurrence
public class FirstOccurrence {
  public int firstOccur(int[] array, int target) {
    if (array == null || array.length == 0) {
      return -1;
    }
    int left = 0;
    int right = array.length - 1;
    // We need to use left < right - 1 here to make sure there is no infinite loop.
    // Think about the case when left == right - 1,
    // then mid == left, it will be possible picking [mid, right] for the next round
    // and it will go into an infinite loop in that case.
    while (left < right - 1) {
      int mid = left + (right - left) / 2;
      if (array[mid] >= target) {
        right = mid;
      } else {
        left = mid;
      }
    }
    // Make sure you understand all the possible situations when entering
    // this postprocessing procedure.
    // 1. array has only 1 element.
    // 2. array has only 2 element.
    // 3. left == right - 1 and left is the result.
    // 4. left == right - 1 and right is the result.
    // 5. left == right - 1 and none of left,right is the result.
    if (array[left] == target) {
      return left;
    } else if (array[right] == target) {
      return right;
    }
    return -1;
  }
}

Last Occurrence
public class LastOccurrence {
  public int lastOccur(int[] array, int target) {
    if (array == null || array.length == 0) {
      return -1;
    }
    int left = 0;
    int right = array.length - 1;
    while (left < right - 1) {
      int mid = left + (right - left) / 2;
      if (array[mid] <= target) {
        left = mid;
      } else {
        right = mid;
      }
    }
    if (array[right] == target) {
      return right;
    } else if (array[left] == target) {
      return left;
    }
    return -1;
  }
}

Closest Number In Sorted Array
public class Closest {
  public int closest(int[] array, int target) {
    if (array == null || array.length == 0) {
      return -1;
    }
    int left = 0;
    int right = array.length - 1;
    while (left < right - 1) {
      int mid = left + (right - left) / 2;
      if (array[mid] == target) {
        return mid;
      } else if (array[mid] < target) {
        left = mid;
      } else {
        right = mid;
      }
    }
    if (Math.abs(array[left] - target) <= Math.abs(array[right] - target)) {
      return left;
    }
    return right;
  }
}

K Closest In Sorted Array
public class KClosest {
  public int[] kClosest(int[] array, int target, int k) {
    if (array == null || array.length == 0) {
      return array;
    }
    if (k == 0) {
      return new int[0];
    }
    // left is the index of the largest smaller or equal element,
    // right = left + 1.
    // These two should be the closest to target.
    int left = largestSmallerEqual(array, target);
    int right = left + 1;
    int[] result = new int[k];
    // this is a typical merge operation.
    for (int i = 0; i < k; i++) {
	// we can advance the left pointer when:
      // 1. right pointer is already out of bound.
      // 2. right pointer is not out of bound, left pointer is not out of
      //    bound, and array[left] is closer to target.
      if (right >= array.length || left >= 0
          && target - array[left] <= array[right] - target) {
        result[i] = array[left--];
      } else {
        result[i] = array[right++];
      }
    }
    return result;
  }

  private int largestSmallerEqual(int[] array, int target) {
    // find the largest smaller or equal element's index in the array
    int left = 0;
    int right = array.length - 1;
    while (left < right - 1) {
      int mid = left + (right - left) / 2;
      if (array[mid] <= target) {
        left = mid;
      } else {
        right = mid;
      }
    }
    if (array[right] <= target) {
      return right;
    }
    if (array[left] <= target) {
      return left;
    }
    // can not find...
    return -1;
  }
}

Search In Unknown Sized Sorted Array
/**
 * Binary search implementation on an dictionary with unknown size. 
 * Assumption:
 * 1). The dictionary is an unknown sized sorted array, it only provides
 *     get(int index) functionality, if the index asked for is out of right 
 *     bound, it will return null.
 * 2). The elements in the dictionary are all Integers.
 */
public class UnknownSizeBinarySearch {
  public int search(Dictionary dictionary, int target) {
    if (dictionary == null) {
      return -1;
    }
    int left = 0;
    int right = 1;
    // find the right boundary for binary search.
    // extends until we are sure the target is within the [left, right] range.
    while (dictionary.get(right) != null && dictionary.get(right) < target) {
      // 1. move left to right
      // 2. double right index
      left = right;
      right = 2 * right;
    }
    return binarySearch(dictionary, target, left, right);
  }

  private int binarySearch(Dictionary dict, int target, int left, int right) {
    // classical binary search
    while (left <= right) {
      int mid = left + (right - left) / 2;
      if (dict.get(mid) == null || dict.get(mid) > target) {
        right = mid - 1;
      } else if (dict.get(mid) < target) {
        left = mid + 1;
      } else {
        return mid;
      }
    }
    return -1;
  }

  public static void main(String[] args) {
    UnknownSizeBinarySearch sol = new UnknownSizeBinarySearch();
    // test cases
    Dictionary dict = new DictImpl(new int[0]);
    int target = 0;
    System.out.println("Expect: -1, Actual: " + sol.search(dict, target)); // expected
                                                                           // -1.
    dict = new DictImpl(new int[] { 1 });
    target = 0;
    System.out.println("Expect: -1, Actual: " + sol.search(dict, target)); // expected
                                                                           // -1.
    dict = new DictImpl(new int[] { 1 });
    target = 1;
    System.out.println("Expect: 0, Actual: " + sol.search(dict, target)); // expected
                                                                          // 0.
    dict = new DictImpl(new int[] { 1 });
    target = 2;
    System.out.println("Expect: -1, Actual: " + sol.search(dict, target)); // expected
                                                                           // -1.
    dict = new DictImpl(new int[] { 1, 3 });
    target = 0;
    System.out.println("Expect: -1, Actual: " + sol.search(dict, target)); // expected
                                                                           // -1.
    dict = new DictImpl(new int[] { 1, 3 });
    target = 3;
    System.out.println("Expect: 1, Actual: " + sol.search(dict, target)); // expected
                                                                          // 1.
    dict = new DictImpl(new int[] { 1, 3 });
    target = 2;
    System.out.println("Expect: -1, Actual: " + sol.search(dict, target)); // expected
                                                                           // -1.
    dict = new DictImpl(new int[] { 1, 3 });
    target = 4;
    System.out.println("Expect: -1, Actual: " + sol.search(dict, target)); // expected
                                                                           // -1.
    dict = new DictImpl(new int[] { 1, 3, 4, 4, 6, 10, 11, 12, 15, 15 });
    target = 0;
    System.out.println("Expect: -1, Actual: " + sol.search(dict, target)); // expected
                                                                           // -1.
    target = 6;
    System.out.println("Expect: 4, Actual: " + sol.search(dict, target)); // expected
                                                                          // 4.
    target = 8;
    System.out.println("Expect: -1, Actual: " + sol.search(dict, target)); // expected
                                                                           // -1.
    dict = new DictImpl(largeArray(100000));
    target = 99999;
    System.out.println("Expect: 99999, Actual: " + sol.search(dict, target)); // expected
                                                                              // 99999.
    target = 100001;
    System.out.println("Expect: -1, Actual: " + sol.search(dict, target)); // expected
                                                                           // -1.
  }

  public static int[] largeArray(int size) {
    int[] array = new int[size];
    for (int i = 0; i < size; i++) {
      array[i] = i;
    }
    return array;
  }
}

interface Dictionary {
  public Integer get(int index);
}


// We do not provide length() to outside.
// NOTICE: You DO NOT need to implement this interface yourself
//         on laicode.com, it is already there when running the
//         tests against your solution.
class DictImpl implements Dictionary {
  private int[] array;

  public DictImpl(int[] array) {
    this.array = array;
  }

  // If the index is out of bound, null will be returned.
  @Override
  public Integer get(int index) {
    if (array == null || index >= array.length) {
      return null;
    }
    return array[index];
  }

  // For pretty printout.
  @Override
  public String toString() {
    if (array == null) {
      return String.valueOf(null);
    }
    if (array.length <= 10) {
      return Arrays.toString(array);
    }
    // Truncate output if array is too large.
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < 5; i++) {
      sb.append(array[i]).append(", ");
    }
    sb.append("......, ");
    for (int i = array.length - 4; i < array.length; i++) {
      sb.append(array[i]);
      if (i != array.length - 1) {
        sb.append(", ");
      }
    }
    sb.append("]");
    return sb.toString();
  }
}

Back To Index

Class 3 - Queue, Stack & Linked List
Implement Queue By Two Stacks
public class QueueByTwoStack {
  // We always insert into the in stack.
  private LinkedList<Integer> in;
  // We always remove from the out stack.
  private LinkedList<Integer> out;

  public QueueByTwoStack() {
    in = new LinkedList<Integer>();
    out = new LinkedList<Integer>();
  }

  public Integer poll() {
    // if out stack is empty,
    // need to move the elements from in stack to out stack.
    move();
    return out.isEmpty() ? null : out.pollFirst();
  }

  public void offer(int value) {
    // always push into the in stack.
    in.offerFirst(value);
  }

  public Integer peek() {
    move();
    return out.isEmpty() ? null : out.peekFirst();
  }

  // when out stack is empty, move the elements from
  // in stack to out stack.
  private void move() {
    if (out.isEmpty()) {
      while (!in.isEmpty()) {
        out.offerFirst(in.pollFirst());
      }
    }
  }

  public int size() {
    return in.size() + out.size();
  }

  public boolean isEmpty() {
    return in.size() == 0 && out.size() == 0;
  }
}

Stack With min()
public class StackWithMin {
  private Deque<Integer> stack;
  private Deque<Integer> minStack;

  public StackWithMin() {
    stack = new LinkedList<Integer>();
    minStack = new LinkedList<Integer>();
  }

  public Integer min() {
    if (minStack.isEmpty()) {
      return null;
    }
    return minStack.peekFirst();
  }

  public void push(int value) {
    stack.offerFirst(value);
    // when value <= current min value in stack,
    // need to push the value to minStack.
    if (minStack.isEmpty() || value <= minStack.peekFirst()) {
      minStack.offerFirst(value);
    }
  }

  public Integer pop() {
    if (stack.isEmpty()) {
      return null;
    }
    Integer result = stack.pollFirst();
    // when the popped value is the same as top value of minStack, the value
    // need to be popped from minStack as well.
    if (minStack.peekFirst().equals(result)) {
      minStack.pollFirst();
    }
    return result;
  }

  public Integer top() {
    if (stack.isEmpty()) {
      return null;
    }
    return stack.peekFirst();
  }
}

Sort Numbers In Three Stacks
/**
 * The numbers are in s1 originally, after sorting, the numbers should be in 
 * s1 as well and from top to bottom the numbers are sorted in ascending 
*  order.
 */
public class SortArrayThreeStacks {
  // Assumptions: s1 is not null.
  public void sort(LinkedList<Integer> s1) {
    LinkedList<Integer> s2 = new LinkedList<Integer>();
    LinkedList<Integer> s3 = new LinkedList<Integer>();
    sort(s1, s2, s3, s1.size());
  }

  private void sort(LinkedList<Integer> s1, LinkedList<Integer> s2, LinkedList<Integer> s3, int length) {
    if (length <= 1) {
      return;
    }
    int mid1 = length / 2;
    int mid2 = length - length / 2;
    for (int i = 0; i < mid1; i++) {
      s2.offerFirst(s1.pollFirst());
    }
    // use the other stacks to sort s2/s1.
    // after sorting the numbers in s2/s1 are in ascending order from top to
    // bottom in the two stacks.
    sort(s2, s3, s1, mid1);
    sort(s1, s3, s2, mid2);
    int i = 0;
    int j = 0;
    while (i < mid1 && j < mid2) {
      if (s2.peekFirst() < s1.peekFirst()) {
        s3.offerFirst(s2.pollFirst());
        i++;
      } else {
        s3.offerFirst(s1.pollFirst());
        j++;
      }
    }
    while (i < mid1) {
      s3.offerFirst(s2.pollFirst());
      i++;
    }
    while (j < mid2) {
      s3.offerFirst(s1.pollFirst());
      j++;
    }
    // after merging, the numbers are in descending order from top to bottom 
    // in s3, we need to push them back to s1 so that they are in ascending 
    // order.
    for (int index = 0; index < length; index++) {
      s1.offerFirst(s3.pollFirst());
    }
  }
}

Reverse Linked List
/**
 * Reverse singled linked list, both iterative and recursive ways.
 */
public class ReverseLinkedList {
  public ListNode reverseLinkedList(ListNode head) {
    ListNode prev = null;
    while (head != null) {
      ListNode next = head.next;
      head.next = prev;
      prev = head;
      head = next;
    }
    return prev;
  }

  public ListNode reverseLinkedListI(ListNode head) {
    // be careful about the base case,
    // need to make sure the later head.next.next != null.
    if (head == null || head.next == null) {
      return head;
    }
    ListNode newHead = reverseLinkedListI(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
  }
}

Find Middle Node Of Linked List
/**
 * Find the middle node of a singled linked list.
 * 1). 1 -> 2 -> 3 ->null, the middle node is 2.
 * 2). 1 -> 2 -> 3 -> 4 -> null, the middle node is 2.
 * 3). null, the middle node is null.
 */
public class MiddleNode {
  public ListNode findMiddle(ListNode head) {
    if (head == null) {
      return null;
    }
    ListNode slow = head;
    ListNode fast = head;
    while (fast.next != null && fast.next.next != null) {
      slow = slow.next;
      fast = fast.next.next;
    }
    return slow;
  }
}

Check If Linked List Has Cycle
public class CheckCycle {
  public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
      return false;
    }
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
      slow = slow.next;
      fast = fast.next.next;
      if (slow == fast) {
        return true;
      }
    }
    return false;
  }
}

Insert In Sorted Linked List
public class InsertSortedList {
  public ListNode insert(ListNode head, int value) {
    ListNode newNode = new ListNode(value);
    // 1. determine if the inserted node is before head.
    if (head == null || head.value >= value) {
      newNode.next = head;
      return newNode;
    }
    // 2. insert the new node to the right position.
    // using the previous node to traverse the linked list
    // the insert position of the new node should be between prev and 
    // prev.next
    ListNode prev = head;
    while (prev.next != null && prev.next.value < value) {
      prev = prev.next;
    }
    newNode.next = prev.next;
    prev.next = newNode;
    return head;
  }
}

Merge Two Sorted Linked List
public class MergeTwoSortedList {
  public ListNode merge(ListNode one, ListNode two) {
    ListNode dummy = new ListNode(0);
    ListNode cur = dummy;
    while (one != null && two != null) {
      if (one.value <= two.value) {
        cur.next = one;
        one = one.next;
      } else {
        cur.next = two;
        two = two.next;
      }
      cur = cur.next;
    }
    // link the remaining possible nodes.
    if (one != null) {
      cur.next = one;
    } else {
      cur.next = two;
    }
    return dummy.next;
  }
}

Reorder Linked List
public class ReorderList {
  public ListNode reorder(ListNode head) {
    if (head == null || head.next == null) {
      return head;
    }
    // 1. find the middle node
    ListNode mid = middleNode(head);
    ListNode one = head;
    ListNode two = mid.next;
    // de-link the second half from the list.
    mid.next = null;
    // 2. reverse the second half
    // 3. merge the two halves
    return merge(one, reverse(two));
  }

  private ListNode middleNode(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    while (fast.next != null && fast.next.next != null) {
      slow = slow.next;
      fast = fast.next.next;
    }
    return slow;
  }

  private ListNode reverse(ListNode head) {
    if (head == null || head.next == null) {
      return head;
    }
    ListNode prev = null;
    while (head != null) {
      ListNode next = head.next;
      head.next = prev;
      prev = head;
      head = next;
    }
    return prev;
  }

  private ListNode merge(ListNode one, ListNode two) {
    ListNode dummy = new ListNode(0);
    ListNode cur = dummy;
    while (one != null && two != null) {
      cur.next = one;
      one = one.next;
      cur.next.next = two;
      two = two.next;
      cur = cur.next.next;
    }
    if (one != null) {
      cur.next = one;
    } else {
      cur.next = two;
    }
    return dummy.next;
  }
}

Partition Linked List
public class PartitionList {
  public ListNode partition(ListNode head, int target) {
    if (head == null || head.next == null) {
      return head;
    }
    ListNode small = new ListNode(0);
    ListNode large = new ListNode(0);
    ListNode curSmall = small;
    ListNode curLarge = large;
    while (head != null) {
      if (head.value < target) {
        curSmall.next = head;
        curSmall = curSmall.next;
      } else {
        curLarge.next = head;
        curLarge = curLarge.next;
      }
      head = head.next;
    }
    // connect the two partitions
    curSmall.next = large.next;
    // un-link the last node in large partition
    curLarge.next = null;
    return small.next;
  }
}

Back To Index

Class 4 - Binary Tree & Binary Search Tree
Binary Tree Pre-order Iterative Traversal
public class PreOrder {
  public List<Integer> preOrder(TreeNode root) {
    List<Integer> preorder = new ArrayList<Integer>();
    if (root == null) {
      return preorder;
    }
    Deque<TreeNode> stack = new LinkedList<TreeNode>();
    stack.offerFirst(root);
    while (!stack.isEmpty()) {
      TreeNode cur = stack.pollFirst();
      // the left subtree should be traversed before right subtree,
      // since stack is LIFO, we should push right into the stack first,
      // so for the next step the top element of the stack is the left 
      // subtree.
      if (cur.right != null) {
        stack.offerFirst(cur.right);
      }
      if (cur.left != null) {
        stack.offerFirst(cur.left);
      }
      preorder.add(cur.key);
    }
    return preorder;
  }
}

Binary Tree In-order Iterative Traversal
public class InOrder {
  public List<Integer> inOrder(TreeNode root) {
    List<Integer> inorder = new ArrayList<Integer>();
    Deque<TreeNode> stack = new LinkedList<TreeNode>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
      // always try go to the left side to see if there is any node
      // should be traversed before the cur node, cur node is stored
      // on stack since it has not been traversed yet.
      if (cur != null) {
        stack.offerFirst(cur);
        cur = cur.left;
      } else {
        // if can not go left, meaning all the nodes on the left side of
        // the top node on stack have been traversed, the next traversing
        // node should be the top node on stack.
        cur = stack.pollFirst();
        inorder.add(cur.key);
        // the next subtree we want to traverse is cur.right.
        cur = cur.right;
      }
    }
    return inorder;
  }
}

Binary Tree Post-order Iterative Traversal
public class PostOrder {
  // Method 1: post-order is the reverse order of pre-order with traversing
  // right subtree before traversing left subtree.
  public List<Integer> postOrderI(TreeNode root) {
    List<Integer> result = new ArrayList<Integer>();
    if (root == null) {
      return result;
    }
    Deque<TreeNode> preOrder = new LinkedList<TreeNode>();
    preOrder.offerFirst(root);
    while (!preOrder.isEmpty()) {
      TreeNode current = preOrder.pollFirst();
      // conduct the result for the special pre-order traversal.
      result.add(current.key);
      // in pre-order the right subtree will be traversed before the
      // left subtree so pushing left child first.
      if (current.left != null) {
        preOrder.offerFirst(current.left);
      }
      if (current.right != null) {
        preOrder.offerFirst(current.right);
      }
    }
    // reverse the pre-order traversal sequence to get the post-order result.
    Collections.reverse(result);
    return result;
  }

  // Method 2: check the relation between the current node and the previous node
  // to determine which direction should go next.
  public List<Integer> postOrderII(TreeNode root) {
    List<Integer> result = new ArrayList<Integer>();
    if (root == null) {
      return result;
    }
    Deque<TreeNode> stack = new LinkedList<TreeNode>();
    stack.offerFirst(root);
    // to record the previous node on the way of DFS so that
    // we can determine the direction.
    TreeNode prev = null;
    while (!stack.isEmpty()) {
      TreeNode cur = stack.peekFirst();
      // if we are going down, either left/right direction.
      if (prev == null || cur == prev.left || cur == prev.right) {
        // if we can still go down, try go left first.
        if (cur.left != null) {
          stack.offerFirst(cur.left);
        } else if (cur.right != null) {
          stack.offerFirst(cur.right);
        } else {
          // if we can not go either way, meaning cur is a leaf node.
          stack.pollFirst();
          result.add(cur.key);
        }
      } else if (prev == cur.right || prev == cur.left && cur.right == null) {
        // if we are going up from the right side or going up from the left side
        // but we can not go right afterwards.
        stack.pollFirst();
        result.add(cur.key);
      } else {
        // otherwise, we are going up from the left side and we can go down
        // right side.
        stack.offerFirst(cur.right);
      }
      prev = cur;
    }
    return result;
  }
}

Check If Binary Tree Is Balanced
public class CheckBalanced {
  public boolean isBalanced(TreeNode root) {
    if (root == null) {
      return true;
    }
    // use -1 to denote the tree is not balanced.
    // >= 0 value means the tree is balanced and it is the height of the tree.
    return height(root) != -1;
  }

  private int height(TreeNode root) {
    if (root == null) {
      return 0;
    }
    int leftHeight = height(root.left);
    // if left subtree is already not balanced, we do not need to continue
    // and we can return -1 directly.
    if (leftHeight == -1) {
      return -1;
    }
    int rightHeight = height(root.right);
    if (rightHeight == -1) {
      return -1;
    }
    // if not balanced, return -1.
    if (Math.abs(leftHeight - rightHeight) > 1) {
      return -1;
    }
    return Math.max(leftHeight, rightHeight) + 1;
  }
}

Check If Binary Tree Is Symmetric
public class CheckSymmetric {
  public boolean isSymmetric(TreeNode root) {
    if (root == null) {
      return true;
    }
    return isSymmetric(root.left, root.right);
  }
  
  private boolean isSymmetric(TreeNode one, TreeNode two) {
    if (one == null && two == null) {
      return true;
    } else if (one == null || two == null) {
      return false;
    } else if (one.key != two.key) {
      return false;
    }
    return isSymmetric(one.left, two.right)
        && isSymmetric(one.right, two.left);
  }
}

Tweaked Identical Binary Trees
public class CheckTweakedIdentical {
  public boolean isTweakedIdentical(TreeNode one, TreeNode two) {
    if (one == null && two == null) {
      return true;
    } else if (one == null || two == null) {
      return false;
    } else if (one.key != two.key) {
      return false;
    }
    return isTweakedIdentical(one.left, two.left) && isTweakedIdentical(one.right, two.right)
        || isTweakedIdentical(one.left, two.right) && isTweakedIdentical(one.right, two.left);
  }
}

Is Binary Search Tree Or Not
public class CheckBST {
  public boolean isBST(TreeNode root) {
    return isBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
  }
  
  private boolean isBST(TreeNode root, int min, int max) {
    if (root == null) {
      return true;
    }
    if (root.key < min || root.key > max) {
      return false;
    }
    return isBST(root.left, min, root.key - 1)
        && isBST(root.right, root.key + 1, max);
  }
}

Get Keys In Binary Search Tree In Given Range
public class GetRange {
  public List<Integer> getRange(TreeNode root, int min, int max) {
    List<Integer> list = new ArrayList<Integer>();
    getRange(root, min, max, list);
    return list;
  }

  private void getRange(TreeNode root, int min, int max, List<Integer> list) {
    if (root == null) {
      return;
    }
    // 1. determine if left subtree should be traversed, only when root.key >
    // min, we should traverse the left subtree.
    if (root.key > min) {
      getRange(root.left, min, max, list);
    }
    // 2. determine if root should be traversed.
    if (root.key >= min && root.key <= max) {
      list.add(root.key);
    }
    // 3. determine if right subtree should be traversed, only when
    //    root.key < max, we should traverse the right subtree.
    if (root.key < max) {
      getRange(root.right, min, max, list);
    }
  }
}

Back To Index

Class 5 - Heap & Graph Search Algorithm I (BFS)
K Smallest In Unsorted Array
/**
 * Find the smallest k elements in an unsorted array.
 * Assumptions: 1). array is not null 2). k >= 0 and k <= array.length
 */
public class KSmallest {
  // Method 1: K sized max heap
  public int[] kSmallestI(int[] array, int k) {
    // handle all possible corner cases at the very beginning.
    if (array.length == 0 || k == 0) {
      return new int[0];
    }
    PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(k, new Comparator<Integer>() {
      @Override
      public int compare(Integer o1, Integer o2) {
        // do not use "==" here !!!
        if (o1.equals(o2)) {
          return 0;
        }
        return o1 > o2 ? -1 : 1;
      }
    });
    for (int i = 0; i < array.length; i++) {
      if (i < k) {
        // offer the first k elements into max heap.
        // NOTICE: if you want to utilize heapify(), the only thing you can do
        // is to call a certain constructor of PriorityQueue.
        maxHeap.offer(array[i]);
      } else if (array[i] < maxHeap.peek()) {
        // for the other elements, only offer it into the max heap if it is
        // smaller than the max value in the max heap.
        maxHeap.poll();
        maxHeap.offer(array[i]);
      }
    }
    int[] result = new int[k];
    for (int i = k - 1; i >= 0; i--) {
      result[i] = maxHeap.poll();
    }
    return result;
  }

  // Method 2: quick select
  public int[] kSmallestII(int[] array, int k) {
    // handle corner cases at the beginning.
    if (array.length == 0 || k == 0) {
      return new int[0];
    }
    // quickselect to find the kth smallest element.
    // after calling this method, the first k elements in the array are
    // the k smallest ones(but not sorted).
    quickSelect(array, 0, array.length - 1, k - 1);
    // copy out the first k elements and sort them.
    int[] result = Arrays.copyOf(array, k);
    Arrays.sort(result);
    return result;
  }

  private void quickSelect(int[] array, int left, int right, int target) {
    // like quick sort, we need to do the partition using pivot value.
    int mid = partition(array, left, right);
    // unlike quick sort, we only need to do quickselect on at most one
    // partition.
    // if the pivot is already the kth smallest element, we can directly return.
    if (mid == target) {
      return;
    } else if (target < mid) {
      // only need to recursively call quick select on the left partition
      // if the kth smallest one is in the left partition.
      quickSelect(array, left, mid - 1, target);
    } else {
      // only need to recursively call quick select on the right partition
      // if the kth smallest one is in the right partition.
      quickSelect(array, mid + 1, right, target);
    }
  }

  private int partition(int[] array, int left, int right) {
    int pivot = array[right];
    int start = left;
    int end = right - 1;
    while (start <= end) {
      if (array[start] < pivot) {
        start++;
      } else if (array[end] >= pivot) {
        end--;
      } else {
        swap(array, start++, end--);
      }
    }
    swap(array, start, right);
    return start;
  }

  private void swap(int[] array, int a, int b) {
    int tmp = array[a];
    array[a] = array[b];
    array[b] = tmp;
  }
}

Get Keys In Binary Tree Layer By Layer
public class LayerByLayer {
  public List<List<Integer>> layerByLayer(TreeNode root) {
    List<List<Integer>> list = new ArrayList<List<Integer>>();
    if (root == null) {
      return list;
    }
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    while (!queue.isEmpty()) {
      // the list storing all the nodes on the current level.
      List<Integer> curLayer = new ArrayList<Integer>();
      // the size of current level.
      int size = queue.size();
      // traverse all the nodes on the current level and
      // prepare for the next level.
      for (int i = 0; i < size; i++) {
        TreeNode cur = queue.poll();
        curLayer.add(cur.key);
        if (cur.left != null) {
          queue.offer(cur.left);
        }
        if (cur.right != null) {
          queue.offer(cur.right);
        }
      }
      list.add(curLayer);
    }
    return list;
  }
}

Bipartite
/**
 * Assumptions:
 * 1). The given graph is not null.
 */
public class Bipartite {
  public boolean isBipartite(List<GraphNode> graph) {
    // use 0 and 1 to denote two different groups.
    // the map maintains for each node which group it belongs to.
    HashMap<GraphNode, Integer> visited = new HashMap<GraphNode, Integer>();
    // the graph can be represented by a list of nodes (if it is not guaranteed
    // to be connected). we have to do BFS from each of the nodes.
    for (GraphNode node : graph) {
      if (!BFS(node, visited)) {
        return false;
      }
    }
    return true;
  }

  private boolean BFS(GraphNode node, HashMap<GraphNode, Integer> visited) {
    // if this node has been traversed, no need to do BFS again.
    if (visited.containsKey(node)) {
      return true;
    }
    Queue<GraphNode> queue = new LinkedList<GraphNode>();
    queue.offer(node);
    // start breadth-first-search from the node, since the node has not been
    // visited, we can assign it to any of the groups, for example, group 0.
    visited.put(node, 0);
    while (!queue.isEmpty()) {
      GraphNode cur = queue.poll();
      // the group assigned for cur node.
      int curGroup = visited.get(cur);
      // the group assigned for any neighbor of cur node.
      int neiGroup = curGroup == 0 ? 1 : 0;
      for (GraphNode nei : cur.neighbors) {
        // if the neighbor has not been visited, just put it in the queue
        // and choose the correct group.
        if (!visited.containsKey(nei)) {
          visited.put(nei, neiGroup);
          queue.offer(nei);
        } else if (visited.get(nei) != neiGroup) {
          // only if the neighbor has been traversed and the group does not
          // match to the desired one, return false.
          return false;
        }
        // if the neighbor has been traversed and the group matches the
        // desired one, we do not need to do anything.
      }
    }
    return true;
  }
}

Check If Binary Tree Is Complete
public class CheckCompleted {
  public boolean isCompleted(TreeNode root) {
    if (root == null) {
      return true;
    }
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    // if the flag is set true, there should not be any child nodes afterwards.
    boolean flag = false;
    queue.offer(root);
    while (!queue.isEmpty()) {
      TreeNode cur = queue.poll();
      // if any of the child is not present, set the flag to true.
      if (cur.left == null) {
        flag = true;
      } else if (flag) {
        // if flag is set but we still see cur has a left child,
        // the binary tree is not a completed one.
        return false;
      } else {
        // if flag is not set and left child is present.
        queue.offer(cur.left);
      }
      // same logic applied to the right child.
      if (cur.right == null) {
        flag = true;
      } else if (flag) {
        return false;
      } else {
        queue.offer(cur.right);
      }
    }
    return true;
  }
}

Kth Smallest Number In Sorted Matrix
/**
 * Assumptions:
 * 1). matrix is not null, N * M where N > 0 and M > 0
 * 2). k > 0 and k <= N * M
 */
public class KthSmallestInSortedMatrix {
  public int kthSmallest(int[][] matrix, int k) {
    int rows = matrix.length;
    int columns = matrix[0].length;
    // Best First Search, need a minheap on the value of each cells.
    PriorityQueue<Cell> minHeap = new PriorityQueue<Cell>(k, new Comparator<Cell>() {
      @Override
      public int compare(Cell c1, Cell c2) {
        if (c1.value == c2.value) {
          return 0;
        }
        return c1.value < c2.value ? -1 : 1;
      }
    });
    // all the generated cells will be marked true,
    // to avoid being generated more than once.
    boolean[][] visited = new boolean[rows][columns];
    minHeap.offer(new Cell(0, 0, matrix[0][0]));
    visited[0][0] = true;
    // iterate k-1 rounds, and Best First Search the smallest k-1 cells.
    for (int i = 0; i < k - 1; i++) {
      Cell cur = minHeap.poll();
      // the neighbor cell will be inserted back to the minheap only if
      // 1. it is not out of boundary.
      // 2. it has not been generated before.
      // Because for each cell it could be generated twice.
      if (cur.row + 1 < rows && !visited[cur.row + 1][cur.column]) {
        minHeap.offer(new Cell(cur.row + 1, cur.column, matrix[cur.row + 1][cur.column]));
        visited[cur.row + 1][cur.column] = true;
      }
      if (cur.column + 1 < columns && !visited[cur.row][cur.column + 1]) {
        minHeap.offer(new Cell(cur.row, cur.column + 1, matrix[cur.row][cur.column + 1]));
        visited[cur.row][cur.column + 1] = true;
      }
    }
    return minHeap.peek().value;
  }

  static class Cell {
    int row;
    int column;
    int value;

    Cell(int row, int column, int value) {
      this.row = row;
      this.column = column;
      this.value = value;
    }
  }
}

Back To Index

Class 6 - Graph Search Algorithm II (DFS)
All Subsets I
/**
 * Assumptions:
 * 1). there are no duplicate characters in the given string.
 */
public class SubSetsI {
  // method 1: DFS solution.
  public List<String> subSets(String set) {
    List<String> result = new ArrayList<String>();
    if (set == null) {
      return result;
    }
    char[] arraySet = set.toCharArray();
    // record the current subset.
    StringBuilder sb = new StringBuilder();
    helper(arraySet, sb, 0, result);
    return result;
  }

  // at each level, determine the character at the position "index" to be picked
  // or not.
  private void helper(char[] set, StringBuilder sb, int index, List<String> result) {
    // terminate condition:
    // when we finishes determining for all the characters pick or not,
    // we have a complete subset.
    if (index == set.length) {
      result.add(sb.toString());
      return;
    }
    // 1. not pick the character at index.
    helper(set, sb, index + 1, result);
    // 2. pick the character at index
    helper(set, sb.append(set[index]), index + 1, result);
    // remember to remove the added character when back tracking to the previous
    // level.
    sb.deleteCharAt(sb.length() - 1);
  }

  // method 2: another DFS solution.
  public List<String> subSetsII(String set) {
    List<String> result = new ArrayList<String>();
    if (set == null) {
      return result;
    }
    char[] arraySet = set.toCharArray();
    StringBuilder sb = new StringBuilder();
    helperII(arraySet, sb, 0, result);
    return result;
  }

  private void helperII(char[] set, StringBuilder sb, int index, List<String> result) {
    result.add(sb.toString());
    // maintains ascending order of the indices of picked characters.
    // choose the next picked index(the smallest one can be picked is index).
    for (int i = index; i < set.length; i++) {
      sb.append(set[i]);
      helperII(set, sb, i + 1, result);
      sb.deleteCharAt(sb.length() - 1);
    }
  }
}

All Valid Permutations Of Parentheses I
public class ValidParenthesesI {
  public List<String> validParentheses(int k) {
    List<String> result = new ArrayList<String>();
    // the final string contains 2k characters.
    char[] cur = new char[k * 2];
    helper(cur, k, k, 0, result);
    return result;
  }

  // left: how many '(' we still have
  // right: how many ')' we still have
  // index: the current position in cur we want to fill in
  //        with either '(' or ')'
  private void helper(char[] cur, int left, int right, int index, List<String> result) {
    // terminate condition:
    // when we do not have any parentheses left.
    if (left == 0 && right == 0) {
      result.add(new String(cur));
      return;
    }
    // when we can add a '('? whenever there is some '(' we can still use.
    if (left > 0) {
      cur[index] = '(';
      helper(cur, left - 1, right, index + 1, result);
      // NOTICE: it looks like we do not do anything when back tracking
      //         to the previous level.
      //         the code is still correct because:
      //         1. we are setting the character at index and when back tracking,
      //            what we need is just 1).remove the character at index and
      //            2). add a different character at index.
      //         2. only when we fill in all the positions in cur, we have
      //            a complete solution.
      //         the code itself actually already suffices the above two points and
      //         it already does the correct removing operation when back tracked to
      //         the previous level.
    }
    // when we can add a ')'? when there is more '(' than ')' used,
    // because each ')' should be associated with a previous '('.
    if (right > left) {
      cur[index] = ')';
      helper(cur, left, right - 1, index + 1, result);
    }
  }
}

Combinations Of Coins
public class CombinationsOfCoins {
  public List<List<Integer>> combinations(int target, int[] coins) {
    // each combination is represented as a List<Integer> cur,
    // and cur.get(i) = the number of coins of coins[i].
    // all the combinations are stored in the result as List of
    // List<Integer>.
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    List<Integer> cur = new ArrayList<Integer>();
    helper(target, coins, 0, cur, result);
    return result;
  }

  // target: remaining cents we need to complete.
  // coins: all the possible different coins.
  // index: we want to see how many coins we need for coins[index].
  private void helper(int target, int[] coins, int index, List<Integer> cur, List<List<Integer>> result) {
    // terminate condition:
    // NOTICE: this can also be done at index == coins.length where all the
    // coins have been picked.
    // but a probably better one is at a previous level to reduce the
    // number of unnecessary branches in the DFS.
    // think about it, coins.length - 1 represents the last coin we
    // can use and actually what we can do at this level is to get
    // target / coins[coins.length - 1] coins if possible.
    if (index == coins.length - 1) {
      if (target % coins[coins.length - 1] == 0) {
        cur.add(target / coins[coins.length - 1]);
        result.add(new ArrayList<Integer>(cur));
        cur.remove(cur.size() - 1);
      }
      return;
    }
    // for coins[index], we can pick 0, 1, 2, ...., target / coins[index] coins.
    int max = target / coins[index];
    for (int i = 0; i <= max; i++) {
      cur.add(i);
      // remember to modify the remaining cents for the next level.
      helper(target - i * coins[index], coins, index + 1, cur, result);
      cur.remove(cur.size() - 1);
    }
  }
}

All Permutations I
public class PermutationsI {
  // 1. DFS solution with swapping
  public List<String> permutations(String set) {
    List<String> result = new ArrayList<String>();
    if (set == null) {
      return result;
    }
    char[] array = set.toCharArray();
    helper(array, 0, result);
    return result;
  }

  // choose the character to be at the position of "index",
  // all the already chosen positions are (0, index-1)
  // all the candidate characters can be at position "index"
  // are in the subarray of (index, array.length-1)
  private void helper(char[] array, int index, List<String> result) {
    // terminate condition:
    // only when we have already chosen the characters for all the position,
    // we can have a complete permutation.
    if (index == array.length) {
      result.add(new String(array));
      return;
    }
    // all the possible characters could be placed at index are
    // the characters in the subarray (index, array.length-1);
    for (int i = index; i < array.length; i++) {
      swap(array, index, i);
      helper(array, index + 1, result);
      // remember to swap back when back track to previous level.
      swap(array, index, i);
    }
  }

  private void swap(char[] array, int left, int right) {
    char tmp = array[left];
    array[left] = array[right];
    array[right] = tmp;
  }

  // 2. Solution to maintain the order of all the permutations.
  public List<String> permutationsWithOrder(String set) {
    List<String> result = new ArrayList<String>();
    if (set == null) {
      return null;
    }
    char[] arraySet = set.toCharArray();
    Arrays.sort(arraySet);
    // record which index has been used in the original arraySet.
    boolean[] used = new boolean[arraySet.length];
    StringBuilder cur = new StringBuilder();
    helperWithOrder(arraySet, used, cur, result);
    return result;
  }

  private void helperWithOrder(char[] array, boolean[] used, StringBuilder cur, List<String> result) {
    // terminate condition:
    // when the permutation contains all the characters in the original array.
    if (cur.length() == array.length) {
      result.add(cur.toString());
      return;
    }
    // when picking the next char, always according to the order.
    for (int i = 0; i < array.length; i++) {
      // if a character is already been used, we can not pick it
      // for a second time.
      if (!used[i]) {
        used[i] = true;
        cur.append(array[i]);
        helperWithOrder(array, used, cur, result);
        used[i] = false;
        cur.deleteCharAt(cur.length() - 1);
      }
    }
  }
}


Back To Index

Class 7 - HashTable & String 1
Top K Frequent Words
public class TopKFrequent {
  // Assumptions: combo is not, and k >= 1.
  public String[] topKFrequent(String[] combo, int k) {
    // handle the special case of empty combo at the very beginning.
    if (combo.length == 0) {
      return new String[0];
    }
    // get all the distinct strings as keys and their frequencies as values.
    // NOTICE: the freqMap has at least size 1.
    Map<String, Integer> freqMap = getFreqMap(combo);
    // minHeap on the frequencies of the strings.
    // NOTICE: using Map.Entry as the element type directly so that all the
    // operations are mostly efficient.
    PriorityQueue<Map.Entry<String, Integer>> minHeap = new PriorityQueue<>(k,
        new Comparator<Map.Entry<String, Integer>>() {
          @Override
          public int compare(Map.Entry<String, Integer> e1, Map.Entry<String, Integer> e2) {
            // compare the frequencies, directly call the compareTo method since
            // the frequencies are represented by Integer.
            return e1.getValue().compareTo(e2.getValue());
          }
        });
    for (Map.Entry<String, Integer> entry : freqMap.entrySet()) {
      if (minHeap.size() < k) {
        minHeap.offer(entry);
      } else if (entry.getValue() > minHeap.peek().getValue()) {
        minHeap.poll();
        minHeap.offer(entry);
      }
    }
    // Since the returned array requires the strings sorted by their
    // frequencies, use a separate helper method to do this operation.
    return freqArray(minHeap);
  }

  private Map<String, Integer> getFreqMap(String[] combo) {
    Map<String, Integer> freqMap = new HashMap<>();
    // NOTICE: when possible, choose the most efficient way for
    // HashMap operations.
    for (String s : combo) {
      Integer freq = freqMap.get(s);
      if (freq == null) {
        freqMap.put(s, 1);
      } else {
        freqMap.put(s, freq + 1);
      }
    }
    return freqMap;
  }

  private String[] freqArray(PriorityQueue<Map.Entry<String, Integer>> minHeap) {
    String[] result = new String[minHeap.size()];
    for (int i = minHeap.size() - 1; i >= 0; i--) {
      result[i] = minHeap.poll().getKey();
    }
    return result;
  }
}

Missing Number I
public class MissingNumberI {
  // Method 1: use HashSet.
  // Assumption: array is not null.
  public int missingI(int[] array) {
    int n = array.length + 1;
    HashSet<Integer> set = new HashSet<Integer>();
    for (int number : array) {
      set.add(number);
    }
    for (int i = 1; i < n; i++) {
      if (!set.contains(i)) {
        return i;
      }
    }
    return n;
  }

  // Method 2: use sum.
  public int missingII(int[] array) {
    int n = array.length + 1;
    long targetSum = (n + 0L) * (n + 1) / 2;
    long actualSum = 0L;
    for (int num : array) {
      actualSum += num;
    }
    return (int) (targetSum - actualSum);
  }

  // Method 3: bit operation. - O(n)
  public int missingIII(int[] array) {
    int n = array.length + 1;
    int xor = 0;
    // xor 1 to n.
    for (int i = 1; i <= n; i++) {
      xor ^= i;
    }
    // after this operation, all the numbers from 1 to n
    // are pair xor'ed except for the missing number.
    // since x ^ x = 0, the remaining number is the result.
    for (int num : array) {
      xor ^= num;
    }
    return xor;
  }

  // Method 4: swap to the original position. - O(n)
  public int missingIV(int[] array) {
    // try to swap the numbers to its corresponding position.
    // for the number x, the corresponding position is x - 1.
    for (int i = 0; i < array.length; i++) {
      // while array[i] is not i+1, swap array[i] to its correct
      // position if possible.
      while (array[i] != i + 1 && array[i] != array.length + 1) {
        swap(array, i, array[i] - 1);
      }
    }
    // if the missing number is in range of 1 - n-1,
    // then we can find it by checking the index i where array[i] != i+1
    for (int i = 0; i < array.length; i++) {
      if (array[i] != i + 1) {
        return i + 1;
      }
    }
    // if all the numbers of 1 - n-1 are in position,
    // the missing number is n.
    return array.length + 1;
  }

  private void swap(int[] array, int i, int j) {
    int tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
  }
}

Common Numbers Of Two Sorted Arrays
// Assumptions: there could be duplicated elements in the given arrays.
public class CommonNumbersII {
  // Method 1: two pointers.
  public List<Integer> commonI(int[] a, int[] b) {
    // Assumption: a, b is not null.
    List<Integer> common = new ArrayList<Integer>();
    int i = 0;
    int j = 0;
    while (i < a.length && j < b.length) {
      if (a[i] == b[j]) {
        common.add(a[i]);
        i++;
        j++;
      } else if (a[i] < b[j]) {
        i++;
      } else {
        j++;
      }
    }
    return common;
  }

  // Method 2: use HashMap.
  public List<Integer> commonII(int[] a, int[] b) {
    List<Integer> common = new ArrayList<Integer>();
    HashMap<Integer, Integer> countA = new HashMap<Integer, Integer>();
    for (int num : a) {
      Integer ct = countA.get(num);
      if (ct != null) {
        countA.put(num, ct + 1);
      } else {
        countA.put(num, 1);
      }
    }
    HashMap<Integer, Integer> countB = new HashMap<Integer, Integer>();
    for (int num : b) {
      Integer ct = countB.get(num);
      if (ct != null) {
        countB.put(num, ct + 1);
      } else {
        countB.put(num, 1);
      }
    }
    for (Map.Entry<Integer, Integer> entry : countA.entrySet()) {
      Integer ctInB = countB.get(entry.getKey());
      if (ctInB != null) {
        int appear = Math.min(entry.getValue(), ctInB);
        for (int i = 0; i < appear; i++) {
          common.add(entry.getKey());
        }
      }
    }
    return common;
  }
}

Remove Certain Characters
public class RemoveCertainCharacters {
  // Assumption: input and t are not null.
  public String remove(String input, String t) {
    // We need to know how to solve this problem with inplace way.
    // Usually we can convert the immutable String to char[].
    char[] array = input.toCharArray();
    // Get set of all distinct characters in t so that lookup
    // operation will be efficient.
    Set<Character> set = buildSet(t);
    // slow: [0, slow) contains the valid result.
    // fast: [fast, array.length) is the area to explore.
    int slow = 0;
    for (int fast = 0; fast < array.length; fast++) {
      // the exploring character can only be put into valid area
      // if it is not in the set.
      if (!set.contains(array[fast])) {
        array[slow++] = array[fast];
      }
    }
    // Convert the char[] subarray back to String Object.
    // Please refer to Java API doc for applicable constructors.
    return new String(array, 0, slow);
  }
  
  private Set<Character> buildSet(String t) {
    Set<Character> set = new HashSet<Character>();
    for (int i = 0; i < t.length(); i++) {
      set.add(t.charAt(i));
    }
    return set;
  }
}

Remove All Leading/Trailing/Duplicate Space Characters
public class RemoveSpaces {
  // Assumption: input is not null.
  public String removeSpaces(String input) {
    if (input.isEmpty()) {
      return input;
    }
    char[] array = input.toCharArray();
    int end = 0;
    for (int i = 0; i < array.length; i++) {
      // when we would ignore the current space character:
      // 1. we ignore all the space characters followed by
      // another space character, so that if there are several
      // consecutive space characters, only the first one will
      // be remained.
      // 2. we ignore also the space character if it is the
      // first character of the input string.
      if (array[i] == ' ' && (i == 0 || array[i - 1] == ' ')) {
        continue;
      }
      array[end++] = array[i];
    }
    // Post-processing: it is possible we still have one trailing
    // space character at the end.
    if (end > 0 && array[end - 1] == ' ') {
      return new String(array, 0, end - 1);
    }
    return new String(array, 0, end);
  }
}

Remove Adjacent Repeated Characters I
public class RemoveDuplicateI {
  // Try to convert the input to char[],
  // and do it in place.
  public String deDup(String input) {
    if (input == null) {
      return null;
    }
    char[] array = input.toCharArray();
    int end = 0;
    for (int i = 0; i < array.length; i++) {
      // repeated characters will be ignored except
      // for the first character in the sequence.
      if (i == 0 || array[i] != array[end - 1]) {
        array[end++] = array[i];
      }
    }
    return new String(array, 0, end);
  }
}

Remove Adjacent Repeated Characters IV
public class RemoveDuplicateIV {
  public String deDup(String input) {
    if (input == null || input.length() <= 1) {
      return input;
    }
    // try to convert the string to char[], and do it in-place.
    char[] array = input.toCharArray();
    // instead of using a extra stack explicitly, we can actually
    // reuse the left side of the original char[] as the "stack".
    // end: is where the top of the stack is.
    int end = 0;
    for (int i = 1; i < array.length; i++) {
      // if the stack is empty(when end==-1) or there is no duplicate chars,
      // we are able to push the character into the stack.
      if (end == -1 || array[i] != array[end]) {
        array[++end] = array[i];
      } else {
        // otherwise, we need pop the top element by end--,
        // and ignore all the consecutive duplicate chars.
        end--;
        while (i + 1 < array.length && array[i] == array[i + 1]) {
          i++;
        }
      }
    }
    return new String(array, 0, end + 1);
  }
}

Determine If One String Is Another’s Substring
// Notice:
// 1. There is no assumption about the charset used in the String,
//    so that we can not assume we are using 26 lower case characters.
// 2. This is the most correct version of RabinKarp in computer programming,
//    we need to handle 1. we could use arbitrary charset, 2. the overflow case,
//    by taking the module operation on a very large number.
// 3. You probably do not need to write this kind of solution to handle above
//    two cases, if you are in an interview. But it is still necessary to
//    understand the reason behind it.
public class Strstr {
  // Method 1: Naive solution.
  public int strstrI(String large, String small) {
    if (large.length() < small.length()) {
      return -1;
    }
    // return 0 if small is empty.
    if (small.length() == 0) {
      return 0;
    }
    for (int i = 0; i <= large.length() - small.length(); i++) {
      if (equals(large, i, small)) {
        return i;
      }
    }
    return -1;
  }

  // Method 2: RabinKarp
  public int strstrII(String large, String small) {
    if (large.length() < small.length()) {
      return -1;
    }
    // return 0 if small is empty.
    if (small.length() == 0) {
      return 0;
    }
    // We need a large prime as module end.
    int largePrime = 101;
    // We also need a small prime to calculate the hash value
    // (since the charset would be very large, e.g. 1,112,064 for using UTF,
    // we can not use that number).
    int prime = 31;
    int seed = 1;
    // hash value is calculated using the smallPrime and taken the module
    // operation on largePrime.
    // hash = (s0*smallP^k + s1*smallP^(k-1) + ... + sk*smallP^0) % largeP
    int targetHash = small.charAt(0) % largePrime;
    for (int i = 1; i < small.length(); i++) {
      seed = moduleHash(seed, 0, prime, largePrime);
      targetHash = moduleHash(targetHash, small.charAt(i), prime, largePrime);
    }
    int hash = 0;
    for (int i = 0; i < small.length(); i++) {
      hash = moduleHash(hash, large.charAt(i), prime, largePrime);
    }
    if (hash == targetHash && equals(large, 0, small)) {
      return 0;
    }
    for (int i = 1; i <= large.length() - small.length(); i++) {
      // we need to make sure the module number is non-negative.
      hash = nonNegative(hash - seed * large.charAt(i - 1) % largePrime, largePrime);
      hash = moduleHash(hash, large.charAt(i + small.length() - 1), prime, largePrime);
      // Notice: If the hash matches, it does not mean we really find a
      // substring match.
      // Because there is collision, we need to check if the substring really
      // matches the small string.
      // On average, this will not increase the time complexity, the probability
      // of collision is O(1) so we still have O(N + M).
      if (hash == targetHash && equals(large, i, small)) {
        return i;
      }
    }
    return -1;
  }

  public boolean equals(String large, int start, String small) {
    for (int i = 0; i < small.length(); i++) {
      if (large.charAt(i + start) != small.charAt(i)) {
        return false;
      }
    }
    return true;
  }

  public int moduleHash(int hash, int addition, int prime, int largePrime) {
    return (hash * prime % largePrime + addition) % largePrime;
  }

  public int nonNegative(int hash, int largePrime) {
    if (hash < 0) {
      hash += largePrime;
    }
    return hash;
  }
}

Back To Index

Class 8 - String II
Reverse String
public class ReverseString {
  // Method 1: iterative reverse.
  public String reverse(String input) {
    if (input == null || input.length() <= 1) {
      return input;
    }
    char[] array = input.toCharArray();
    for (int left = 0, right = array.length - 1; left < right; left++, right--) {
      swap(array, left, right);
    }
    return new String(array);
  }

  // Method 2: recursive reverse.
  public String reverseRecursive(String input) {
    if (input == null || input.length() <= 1) {
      return input;
    }
    char[] array = input.toCharArray();
    reverseHelper(array, 0, array.length - 1);
    return new String(array);
  }

  private void reverseHelper(char[] array, int left, int right) {
    if (left >= right) {
      return;
    }
    swap(array, left, right);
    reverseHelper(array, left + 1, right - 1);
  }

  private void swap(char[] array, int a, int b) {
    char tmp = array[a];
    array[a] = array[b];
    array[b] = tmp;
  }
}

Reverse Words In Sentence
public class ReverseWords {
  // Assumptions:
  // 1). The words are separated by one space character.
  // 2). There are no leading or trailing spaces.
  // 3). input is not null.
  public String reverseWords(String input) {
    // try to convert it to char array and
    // solve the problem in-palce.
    char[] array = input.toCharArray();
    // 1. reverse the whole char array.
    reverse(array, 0, array.length - 1);
    int start = 0;
    // 2. reverse each of the words.
    for (int i = 0; i < array.length; i++) {
      // the start index of a word.
      if (array[i] != ' ' && (i == 0 || array[i - 1] == ' ')) {
        start = i;
      }
      // the end index of a word.
      if (array[i] != ' ' && (i == array.length - 1 || array[i + 1] == ' ')) {
        reverse(array, start, i);
      }
    }
    return new String(array);
  }

  private void reverse(char[] array, int left, int right) {
    while (left < right) {
      char temp = array[left];
      array[left] = array[right];
      array[right] = temp;
      left++;
      right--;
    }
  }
}

Right Shift By N Characters
public class RightShift {
  // Assumption: input is not null, n >= 0.
  public String rightShift(String input, int n) {
    if (input.length() <= 1) {
      return input;
    }
    char[] array = input.toCharArray();
    n %= array.length;
    reverse(array, array.length - n, array.length - 1);
    reverse(array, 0, array.length - n - 1);
    reverse(array, 0, array.length - 1);
    return new String(array);
  }

  private void reverse(char[] array, int left, int right) {
    while (left < right) {
      char tmp = array[left];
      array[left] = array[right];
      array[right] = tmp;
      left++;
      right--;
    }
  }
}

String Replace
public class StringReplace {
  // Method 1: Not using any String/StringBuilder utility,
  // and using char[] to do it "in place".
  public String replaceI(String input, String s, String t) {
    // Assumptions: input, s, t are not null, s is not empty.
    char[] array = input.toCharArray();
    if (s.length() >= t.length()) {
      return replaceShorter(array, s, t);
    }
    return replaceLonger(array, s, t);
  }

  public String replaceShorter(char[] input, String s, String t) {
    // We reuse the input char array since the number of characters needed is
    // less.
    // fast and slow pointers both from left to right direction.
    int slow = 0;
    int fast = 0;
    while (fast < input.length) {
      // when we find a match of s on the substring starting from the fast
      // pointer
      // we copy the t at slow pointer.
      if (fast <= input.length - s.length() && equalSubstring(input, fast, s)) {
        copySubstring(input, slow, t);
        slow += t.length();
        fast += s.length();
      } else {
        input[slow++] = input[fast++];
      }
    }
    return new String(input, 0, slow);
  }

  public String replaceLonger(char[] input, String s, String t) {
    // Notice: we will need a longer array in the case, and if the requirement
    // is "in place", usually you can assume you are given a long enough
    // char array already, and the original input string resides
    // on part of the char array starting from index 0.
    // In this solution, we actually allocate a larger array on demand, and the
    // purpose of the solution is to demonstrate how to do it "in place".

    // get all the matches end positions in the input char array of string s.
    ArrayList<Integer> matches = getAllMatches(input, s);
    // calculate the new length needed.
    char[] result = new char[input.length + matches.size() * (t.length() - s.length())];
    // fast and slow pointers both from right to left direction.
    // fast: the position when traversing the new length.
    // slow: the position when traversing the old length.
    // lastIndex: the rightmost matching end position’s index.
    int lastIndex = matches.size() - 1;
    int slow = input.length - 1;
    int fast = result.length - 1;
    while (slow >= 0) {
      // only if we still have some match and slow is in the position of
      // rightmost matching end position, we should copy t.
      if (lastIndex >= 0 && slow == matches.get(lastIndex)) {
        copySubstring(result, fast - t.length() + 1, t);
        fast -= t.length();
        slow -= s.length();
        lastIndex--;
      } else {
        result[fast--] = input[slow--];
      }
    }
    return new String(result);
  }

  // check if the substring from fromIndex is the same as s.
  private boolean equalSubstring(char[] input, int fromIndex, String s) {
    for (int i = 0; i < s.length(); i++) {
      if (input[fromIndex + i] != s.charAt(i)) {
        return false;
      }
    }
    return true;
  }

  // copy the string t to result at fromIndex.
  private void copySubstring(char[] result, int fromIndex, String t) {
    for (int i = 0; i < t.length(); i++) {
      result[fromIndex + i] = t.charAt(i);
    }
  }

  // get all the matches of s end positions in input.
  private ArrayList<Integer> getAllMatches(char[] input, String s) {
    ArrayList<Integer> matches = new ArrayList<Integer>();
    int i = 0;
    while (i <= input.length - s.length()) {
      if (equalSubstring(input, i, s)) {
        // we record the match substring's end index instead of start index,
        // for later convenience.
        matches.add(i + s.length() - 1);
        i += s.length();
      } else {
        i++;
      }
    }
    return matches;
  }

  // Method 2: Using Java's StringBuilder utility and String's indexof(),
  // not using String's replace()...
  public String replaceII(String input, String s, String t) {
    // Assumptions: input, s, t are not null, s is not empty.
    StringBuilder sb = new StringBuilder();
    // We check if there exists a substring same as s
    // in the substring of input starting at fromIndex.
    int fromIndex = 0;
    int matchIndex = input.indexOf(s, fromIndex);
    while (matchIndex != -1) {
      sb.append(input, fromIndex, matchIndex).append(t);
      // Next time we need to start from matchIndex + s.length()
      // to find if we have later matches.
      fromIndex = matchIndex + s.length();
      matchIndex = input.indexOf(s, fromIndex);
    }
    sb.append(input, fromIndex, input.length());
    return sb.toString();
  }
}

String Shuffling
/**
 * Array reorder in place implementation.
 * 
 * Suppose I have a array of chars, the requirement is as follow:
 * 1). [C_1, C_2, ..., C_2k]
 * --> [C_1, C_k+1, C2, C_k+2, ..., C_k, C_2k]
 * 
 * 2). [C_1, C_2, ..., C_2k+1]
 * --> [C_1, C_K+1, C2, C_K+2, ... C_K, C_2k, C_2k+1]
 */
public class ReOrderArray {
  public int[] reorder(int[] array) {
    // Assumptions: array is not null.
    if (array.length % 2 == 0) {
      reorder(array, 0, array.length - 1);
    } else {
      // if array has odd number of elements, we ignore the last one
      // when do the reordering.
      reorder(array, 0, array.length - 2);
    }
    return array;
  }

  private void reorder(int[] array, int left, int right) {
    int length = right - left + 1;
    // if the subarray has 2 or 0 elements, we can just return
    // as this should be the base case.
    if (length <= 2) {
      return;
    }
    // Calculate the important mid points:
    // 0 1 2 3 4 5 6 7
    // lm: 2, m: 4, rm: 6
    // 0 1 2 3 4 5 6 7 8 9
    // lm: 2, m: 5, rm: 7
    int mid = left + length / 2;
    int lmid = left + length / 4;
    int rmid = left + length * 3 / 4;
    reverse(array, lmid, mid - 1);
    reverse(array, mid, rmid - 1);
    reverse(array, lmid, rmid - 1);
    // half of the left partition's size = lmid - left.
    reorder(array, left, left + (lmid - left) * 2 - 1);
    reorder(array, left + (lmid - left) * 2, right);
  }

  private void reverse(int[] array, int left, int right) {
    while (left < right) {
      int tmp = array[left];
      array[left] = array[right];
      array[right] = tmp;
      left++;
      right--;
    }
  }
}

All Permutations II(with duplicate characters)
public class PermutationsII {
  public List<String> permutations(String set) {
    List<String> result = new ArrayList<String>();
    if (set == null) {
      return result;
    }
    char[] array = set.toCharArray();
    helper(array, 0, result);
    return result;
  }

  // index: at the level of index, we are to determine for the current
  // permutation, which element is positioned at the index.
  private void helper(char[] array, int index, List<String> result) {
    if (index == array.length) {
      // base case: when we have determined for all the indices of
      // the current permutation which element to choose.
      result.add(new String(array));
      return;
    }
    // Notice: the rule is just for the current level, if a certain element
    // is picked, we can not pick any of its duplicates.
    // so that we use a set to record all the distinct elements.
    Set<Character> used = new HashSet<Character>();
    for (int i = index; i < array.length; i++) {
      // user.add(array[i]) will return false if the value of array[i]
      // is already in the Set.
      if (used.add(array[i])) {
        swap(array, i, index);
        // go for the next level, index + 1
        helper(array, index + 1, result);
        // don't forget to do the clear operation when backtracking.
        swap(array, i, index);
      }
    }
  }

  private void swap(char[] array, int left, int right) {
    char tmp = array[left];
    array[left] = array[right];
    array[right] = tmp;
  }
}

Decompress String II
/**
 * Given a string in compressed form, decompress it to the original string. The
 * adjacent repeated characters in the original string are compressed to have
 * the character followed by the number of repeated occurrences.
 * 
 * Assumptions: 1. The string is not null 2. The characters used in the original
 * string are guaranteed to be 'a' - 'z' 3. There are no adjacent repeated
 * characters with length > 9.
 * 
 * Examples: "a1c0c2" --> "acc"
 */
public class DecompressStringII {
  // Method 1: "in place".
  // When we say in place, it usually means the input is a long enough
  // char array, and the original string only occupies part of the array
  // starting from index 0, and usually the length to represent the
  // original string is given.
  public String decompressI(String input) {
    if (input.isEmpty()) {
      return input;
    }
    char[] array = input.toCharArray();
    // We need to handle the
    // "a0", "a1", "a2" case (the decoded string is shorter) and
    // "a3", "a4" ... case (the decoded string is longer)
    // in two pass to avoid conflict, since the encoding of the two cases
    // require different directions.
    return decodeLong(array, decodeShort(array));
  }

  // return the length of he decoded string,
  // only cares about "a0", "a1", "a2", A.K.A
  // the decoded string is shorter.
  private int decodeShort(char[] input) {
    // since the decoded string is shorter, we should
    // do the decoding work from left to right direction.
    int end = 0;
    for (int i = 0; i < input.length; i += 2) {
      int digit = getDigit(input[i + 1]);
      if (digit >= 0 && digit <= 2) {
        for (int j = 0; j < digit; j++) {
          input[end++] = input[i];
        }
      } else {
        // we don't handle the longer decoded string here.
        input[end++] = input[i];
        input[end++] = input[i + 1];
      }
    }
    return end;
  }

  // take care of "a3", "a4", "a5",....
  // the decoded string is longer.
  // length: the length of the valid partition starting from index 0.
  private String decodeLong(char[] input, int length) {
    // we need to calculate the new required length.
    int newLength = length;
    for (int i = 0; i < length; i++) {
      int digit = getDigit(input[i]);
      if (digit > 2 && digit <= 9) {
        newLength += digit - 2;
      }
    }
    // Notice: if it is required to do this in place, usually the input
    // array is a sufficient large one, you will not need to
    // allocate a new array. This solution is only for demonstration.
    char[] result = new char[newLength];
    int end = newLength - 1;
    for (int i = length - 1; i >= 0; i--) {
      int digit = getDigit(input[i]);
      if (digit > 2 && digit <= 9) {
        i--;
        for (int j = 0; j < digit; j++) {
          result[end--] = input[i];
        }
      } else {
        // we already take care the shorter cases, "a1" in previous pass.
        // we can leave as it is. e.g. the input could be "abc2".
        result[end--] = input[i];
      }
    }
    return new String(result);
  }

  private int getDigit(char digit) {
    return digit - '0';
  }

  // Method 2: using StringBuilder to help.
  public String decompressII(String input) {
    // Assumptions: input is not null.
    char[] array = input.toCharArray();
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < array.length; i++) {
      char ch = array[i++];
      int count = array[i] - '0';
      for (int c = 0; c < count; c++) {
        sb.append(ch);
      }
    }
    return sb.toString();
  }
}

Longest Substring With Only Unique Characters
public class LongestSubstringNonRepeatingCharacter {
  public int longest(String input) {
    // Assumptions: the input string is not null.
    // the distinct set contains all distinct characters
    // in the sliding window of (slow, fast).
    Set<Character> distinct = new HashSet<>();
    int slow = 0;
    int fast = 0;
    int longest = 0;
    while (fast < input.length()) {
      if (distinct.contains(input.charAt(fast))) {
        // if there is duplicate character, we need to move
        // the slow pointer.
        distinct.remove(input.charAt(slow++));
      } else {
        // if there is no duplicate character, we can slide
        // fast pointer and we have a new sliding window of
        // (slow, fast) containing all distinct characters.
        distinct.add(input.charAt(fast++));
        longest = Math.max(longest, fast - slow);
      }
    }
    return longest;
  }
}

Find All Anagrams Of Short String In A Long String
public class AllAnagrams {
  // Find all anagrams of String s in String l, return all the starting indices.
  // Assumptions: s,l are not null, s is not empty.
  public List<Integer> allAnagrams(String s, String l) {
    List<Integer> result = new ArrayList<Integer>();
    if (l.length() == 0) {
      return result;
    }
    // when s is longer than l, there is no way any of the substrings of l
    // could be an anagram of s.
    if (s.length() > l.length()) {
      return result;
    }
    // This map records for each of the distinct characters in s,
    // how many characters are needed.
    // e.g. s = "abbc', map = {'a':1, 'b':2, 'c':1}
    // when we get an instance of 'a' in l, we let count of 'a' decremented by 1,
    // and only when the count is from 1 to 0, we have 'a' totally matched.
    Map<Character, Integer> map = countMap(s);
    // Record how many distinct characters have been matched.
    // only when all the distinct characters are matched, A.K.A.
    // match == map.size(), we find an anagram.
    int match = 0;
    // We have a sliding window of size s.length(), and since the size is fixed,
    // we only need to record the end index of the sliding window.
    // Also, when move the sliding window by one step from left to right,
    // what we only need to change is
    // 1. remove the leftmost character at the previous sliding window.
    // 2. add the rightmost character at the current sliding window.
    for (int i = 0; i < l.length(); i++) {
      // handle the new added character(rightmost) at the current sliding window.
      char tmp = l.charAt(i);
      Integer count = map.get(tmp);
      if (count != null) {
        // the number of needed count should be --.
        // and only when the count is from 1 to 0, we find an additional
        // match of distinct character.
        map.put(tmp, count - 1);
        if (count == 1) {
          match++;
        }
      }
      // handle the leftmost character at the previous sliding window.
      if (i >= s.length()) {
        tmp = l.charAt(i - s.length());
        count = map.get(tmp);
        if (count != null) {
          // the number of needed count should be ++.
          // and only when the count is from 0 to 1, we are short for one
          // match of distinct character.
          map.put(tmp, count + 1);
          if (count == 0) {
            match--;
          }
        }
      }
      // for the current sliding window, if all the distinct characters are matched
      // (the count are all zero).
      if (match == map.size()) {
        result.add(i - s.length() + 1);
      }
    }
    return result;
  }

  private Map<Character, Integer> countMap(String s) {
    Map<Character, Integer> map = new HashMap<Character, Integer>();
    for (char ch : s.toCharArray()) {
      Integer count = map.get(ch);
      if (count == null) {
        map.put(ch, 1);
      } else {
        map.put(ch, count + 1);
      }
    }
    return map;
  }
}


Back To Index

Class 10 - Recursion II
N Queens
public class NQueens {
  // Method 1: validate the queen position in O(n) each time.
  public List<List<Integer>> nqueens(int n) {
    // Assumptions: n > 0.
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    // cur will be a list of size n, and cur[i] is the column number
    // where the queen on row i positioned.
    List<Integer> cur = new ArrayList<Integer>();
    helper(n, cur, result);
    return result;
  }

  private void helper(int n, List<Integer> cur, List<List<Integer>> result) {
    // base case: when for all the rows we know where the queen is positioned.
    if (cur.size() == n) {
      result.add(new ArrayList<Integer>(cur));
      return;
    }
    for (int i = 0; i < n; i++) {
      // check if putting a queen at column i at current row is valid.
      if (valid(cur, i)) {
        cur.add(i);
        helper(n, cur, result);
        cur.remove(cur.size() - 1);
      }
    }
  }

  private boolean valid(List<Integer> cur, int column) {
    int row = cur.size();
    for (int i = 0; i < row; i++) {
      if (cur.get(i) == column || Math.abs(cur.get(i) - column) == row - i) {
        return false;
      }
    }
    return true;
  }

  // Method 2: validate the queen position in O(1) each time.
  public List<List<Integer>> nqueensII(int n) {
    // Assumptions: n > 0.
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    // cur will be a list of size n, and cur[i] is the column number
    // where the queen on row i positioned.
    int[] cur = new int[n];
    // record on which columns there is already a queen.
    boolean[] usedColumns = new boolean[n];
    // record on which diagonal lines there is already a queen.
    boolean[] usedDiagonals = new boolean[2 * n - 1];
    // record on which reverse diagonal lines there is already a queen.
    boolean[] usedRevDiagonals = new boolean[2 * n - 1];
    helper(n, 0, cur, result, usedColumns, usedDiagonals, usedRevDiagonals);
    return result;
  }

  private void helper(int n, int row, int[] cur, List<List<Integer>> result, boolean[] usedColumns, boolean[] usedDiagonals, boolean[] usedRevDiagonals) {
    // base case: when for all the rows we know where the queen is positioned.
    if (row == n) {
      result.add(toList(cur));
      return;
    }
    for (int i = 0; i < n; i++) {
      if (valid(n, row, i, usedColumns, usedDiagonals, usedRevDiagonals)) {
        mark(n, row, i, usedColumns, usedDiagonals, usedRevDiagonals);
        cur[row] = i;
        helper(n, row + 1, cur, result, usedColumns, usedDiagonals, usedRevDiagonals);
        unMark(n, row, i, usedColumns, usedDiagonals, usedRevDiagonals);
      }
    }
  }

  private boolean valid(int n, int row, int column, boolean[] usedColumns, boolean[] usedDiagonals, boolean[] usedRevDiagonals) {
    // for the reverse diagonal line, the actual range of column - row is
    // actually [-(n-1), +(n-1)],
    // we add n - 1 to make sure it can fit into the index.
    return !usedColumns[column] && !usedDiagonals[column + row] && !usedRevDiagonals[column - row + n - 1];
  }

  private void mark(int n, int row, int column, boolean[] usedColumns, boolean[] usedDiagonals, boolean[] usedRevDiagonals) {
    usedColumns[column] = true;
    usedDiagonals[column + row] = true;
    usedRevDiagonals[column - row + n - 1] = true;
  }

  private void unMark(int n, int row, int column, boolean[] usedColumns, boolean[] usedDiagonals, boolean[] usedRevDiagonals) {
    usedColumns[column] = false;
    usedDiagonals[column + row] = false;
    usedRevDiagonals[column - row + n - 1] = false;
  }

  private List<Integer> toList(int[] array) {
    List<Integer> list = new ArrayList<>();
    for (int num : array) {
      list.add(num);
    }
    return list;
  }
}

Spiral Order Traverse I
public class SpiralTraverseI {
  // Method 1: Recursive traversal.
  public List<Integer> spiral(int[][] matrix) {
    // Assumptions: matrix is N * N, N >= 0, matrix is not null.
    List<Integer> list = new ArrayList<Integer>();
    recursiveTraverse(matrix, 0, matrix.length, list);
    return list;
  }

  private void recursiveTraverse(int[][] matrix, int offset, int size, List<Integer> result) {
    // the base case is when there is only 0 or 1 element left.
    if (size == 0) {
      return;
    }
    // do not forget this base case.
    if (size == 1) {
      result.add(matrix[offset][offset]);
      return;
    }
    for (int i = 0; i < size - 1; i++) {
      result.add(matrix[offset][offset + i]);
    }
    for (int i = 0; i < size - 1; i++) {
      result.add(matrix[offset + i][offset + size - 1]);
    }
    for (int i = size - 1; i >= 1; i--) {
      result.add(matrix[offset + size - 1][offset + i]);
    }
    for (int i = size - 1; i >= 1; i--) {
      result.add(matrix[offset + i][offset]);
    }
    recursiveTraverse(matrix, offset + 1, size - 2, result);
  }

  // Method 2: Iterative traversal.
  public List<Integer> spiralII(int[][] matrix) {
    // Assumptions: matrix is N * N, N >= 0, matrix is not null.
    List<Integer> list = new ArrayList<Integer>();
    int n = matrix.length;
    int start = 0;
    int end = n - 1;
    // the base case is when there is 0 or 1 element in the submatrix,
    // A.K.A start < end or start == end.
    while (start < end) {
      for (int i = start; i <= end; i++) {
        list.add(matrix[start][i]);
      }
      for (int i = start + 1; i <= end - 1; i++) {
        list.add(matrix[i][end]);
      }
      for (int i = end; i >= start; i--) {
        list.add(matrix[end][i]);
      }
      for (int i = end - 1; i >= start + 1; i--) {
        list.add(matrix[i][start]);
      }
      start++;
      end--;
    }
    // if at last we have 1 element left, we need to traverse it as well.
    if (start == end) {
      list.add(matrix[start][end]);
    }
    return list;
  }
}
Spiral Order Traverse II
public class SpiralTraverseII {
  public List<Integer> spiral(int[][] matrix) {
    // Assumptions: matrix is not null, has size of M * N, where M, N >=0
    List<Integer> list = new ArrayList<Integer>();
    int m = matrix.length;
    // need to handle this case since if m == 0, matrix[0].length will
    // throw ArrayIndexOutofBoundExecption.
    if (m == 0) {
      return list;
    }
    int n = matrix[0].length;
    int left = 0;
    int right = n - 1;
    int up = 0;
    int down = m - 1;
    // the base case is a little complicated comparing to N*N matrix.
    // 1. there is nothing left.
    // 2. there is one row left.
    // 3. there is one column left.
    while (left < right && up < down) {
      for (int i = left; i <= right; i++) {
        list.add(matrix[up][i]);
      }
      for (int i = up + 1; i <= down - 1; i++) {
        list.add(matrix[i][right]);
      }
      for (int i = right; i >= left; i--) {
        list.add(matrix[down][i]);
      }
      for (int i = down - 1; i >= up + 1; i--) {
        list.add(matrix[i][left]);
      }
      left++;
      right--;
      up++;
      down--;
    }
    // 1. if there is nothing left.
    if (left > right || up > down) {
      return list;
    }
    // 2. if there is one column left.
    if (left == right) {
      for (int i = up; i <= down; i++) {
        list.add(matrix[i][left]);
      }
    } else {
      // 3. if there is one row left.
      for (int i = left; i <= right; i++) {
        list.add(matrix[up][i]);
      }
    }
    return list;
  }
}

Spiral Order Generate I
public class SpiralGenerateI {
  // Method 1: Recursive Generate.
  public int[][] spiralGenerate(int n) {
    // Assumptions: n >= 0.
    int[][] matrix = new int[n][n];
    if (n == 0) {
      return matrix;
    }
    recursiveGenerate(matrix, 0, n, 1);
    return matrix;
  }

  private void recursiveGenerate(int[][] matrix, int offset, int size, int num) {
    // the base case is when there is only 0 or 1 element left.
    if (size == 0) {
      return;
    }
    // do not forget this base case.
    if (size == 1) {
      matrix[offset][offset] = num;
      return;
    }
    for (int i = 0; i < size - 1; i++) {
      matrix[offset][offset + i] = num++;
    }
    for (int i = 0; i < size - 1; i++) {
      matrix[offset + i][offset + size - 1] = num++;
    }
    for (int i = size - 1; i >= 1; i--) {
      matrix[offset + size - 1][offset + i] = num++;
    }
    for (int i = size - 1; i >= 1; i--) {
      matrix[offset + i][offset] = num++;
    }
    recursiveGenerate(matrix, offset + 1, size - 2, num);
  }

  // Method 2: Iterative Generate.
  public int[][] spiralGenerateII(int n) {
    // Assumptions: n >= 0.
    int[][] matrix = new int[n][n];
    if (n == 0) {
      return matrix;
    }
    int start = 0;
    int end = n - 1;
    int num = 1;
    // the base case is there is 0 or 1 element left.
    while (start < end) {
      for (int i = start; i <= end; i++) {
        matrix[start][i] = num++;
      }
      for (int i = start + 1; i <= end - 1; i++) {
        matrix[i][end] = num++;
      }
      for (int i = end; i >= start; i--) {
        matrix[end][i] = num++;
      }
      for (int i = end - 1; i >= start + 1; i--) {
        matrix[i][start] = num++;
      }
      start++;
      end--;
    }
    // do not forget one of the base cases is there is
    // one element left.
    if (start == end) {
      matrix[start][end] = num++;
    }
    return matrix;
  }
}

Spiral Order Generate II
public class SpiralGenerateII {
  public int[][] spiralGenerate(int m, int n) {
    // Assumptions: m, n >= 0
    int[][] matrix = new int[m][n];
    if (m == 0 || n == 0) {
      return matrix;
    }
    int num = 1;
    int left = 0;
    int right = n - 1;
    int up = 0;
    int down = m - 1;
    while (left < right && up < down) {
      for (int i = left; i <= right; i++) {
        matrix[up][i] = num++;
      }
      for (int i = up + 1; i <= down - 1; i++) {
        matrix[i][right] = num++;
      }
      for (int i = right; i >= left; i--) {
        matrix[down][i] = num++;
      }
      for (int i = down - 1; i >= up + 1; i--) {
        matrix[i][left] = num++;
      }
      left++;
      right--;
      up++;
      down--;
    }
    if (left > right || up > down) {
      return matrix;
    }
    if (left == right) {
      for (int i = up; i <= down; i++) {
        matrix[i][left] = num++;
      }
    } else {
      for (int i = left; i <= right; i++) {
        matrix[up][i] = num++;
      }
    }
    return matrix;
  }
}

Reverse Linked List In Pairs
public class ReverseListInPairs {
  // Method 1: recursion.
  public ListNode reverseInPairs(ListNode head) {
    if (head == null || head.next == null) {
      return head;
    }
    ListNode newHead = head.next;
    head.next = reverseInPairs(head.next.next);
    newHead.next = head;
    return newHead;
  }
  
  // Method 2: iterative.
  public ListNode reverseInPairsI(ListNode head) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode cur = dummy;
    while (cur.next != null && cur.next.next != null) {
      ListNode next = cur.next.next;
      cur.next.next = cur.next.next.next;
      next.next = cur.next;
      cur.next = next;
      cur = cur.next.next;
    }
    return dummy.next;
  }
}

Abbreviation Matching
public class AbbMatch {
  // Method 1: Recursive way.
  public boolean match(String input, String pattern) {
    // Assumptions: input, pattern are not null.
    return match(input, pattern, 0, 0);
  }

  private boolean match(String s, String t, int si, int ti) {
    // only when we run out of s and t at the same time,
    // there is a match.
    if (si == s.length() && ti == t.length()) {
      return true;
    }
    // if we run out of one of s and t but there is still some
    // characters left for the other one, we can not find the match.
    if (si >= s.length() || ti >= t.length()) {
      return false;
    }
    // case 1. if the current character in t is not a digit.
    if (t.charAt(ti) < '0' || t.charAt(ti) > '9') {
      if (s.charAt(si) == t.charAt(ti)) {
        return match(s, t, si + 1, ti + 1);
      }
      return false;
    }
    // case 2. if the current character in t is a digit.
    // we need to find in total what is the number.
    // e.g. "123" means number 123.
    int count = 0;
    while (ti < t.length() && t.charAt(ti) >= '0' && t.charAt(ti) <= '9') {
      count = count * 10 + (t.charAt(ti) - '0');
      ti++;
    }
    return match(s, t, si + count, ti);
  }

  // Method 2: Iterative way.
  // Notice that the above recursive solution is a TAIL recursion,
  // it is very easy to convert it to an iterative one.
  public boolean matchII(String input, String pattern) {
    // Assumptions: input, pattern are not null.
    int si = 0;
    int ti = 0;
    while (si < input.length() && ti < pattern.length()) {
      if (pattern.charAt(ti) < '0' || pattern.charAt(ti) > '9') {
        if (input.charAt(si) != pattern.charAt(ti)) {
          return false;
        }
        si++;
        ti++;
      } else {
        int count = 0;
        while (ti < pattern.length() && pattern.charAt(ti) >= '0' && pattern.charAt(ti) <= '9') {
          count = count * 10 + (pattern.charAt(ti) - '0');
          ti++;
        }
        si += count;
      }
    }
    return si == input.length() && ti == pattern.length();
  }
}

Store Number Of Nodes In Left Subtree
public class NumNodesLeft {
  static class TreeNode {
    int key;
    TreeNode left;
    TreeNode right;
    // stores the # of nodes in left subtree.
    int numNodesLeft;

    public TreeNode(int key) {
      this.key = key;
    }
  }

  public void numNodesLeft(TreeNode root) {
    numNodes(root);
  }

  // return the # of nodes in the subtree.
  private int numNodes(TreeNode root) {
    if (root == null) {
      return 0;
    }
    // leftNum is the # of nodes in subtree of root.left
    int leftNum = numNodes(root.left);
    // rightNum is the # of nodes in subtree of root.right
    int rightNum = numNodes(root.right);
    root.numNodesLeft = leftNum;
    // return the total # of nodes in the subtree of root.
    return leftNum + rightNum + 1;
  }
}

Given a binary tree, find the node with the max difference in the total number descendents in its left subtree and right subtree
public class MaxDiffNode {
  public TreeNode maxDiffNode(TreeNode root) {
    if (root == null) {
      return null;
    }
    TreeNode[] node = new TreeNode[1];
    int[] diff = new int[1];
    diff[0] = -1;
    numNodes(root, node, diff);
    return node[0];
  }

  // return the # of nodes in the subtree.
  private int numNodes(TreeNode root, TreeNode[] node, int[] diff) {
    if (root == null) {
      return 0;
    }
    int leftNum = numNodes(root.left, node, diff);
    int rightNum = numNodes(root.right, node, diff);
    if (Math.abs(leftNum - rightNum) > diff[0]) {
      node[0] = root;
      diff[0] = Math.abs(leftNum - rightNum);
    }
    return leftNum + rightNum + 1;
  }
}

Lowest Common Ancestor I
public class LCAI {
  // return:
  // null - there is no one or two in the subtree.
  // non null -
  // 1). if there is only one node of one/two in the subtree,
  //     just return the one/two itself.
  // 2). if there both one/two are in the subtree, return the LCA.
  //     a). one is two's descendant, return one.
  //     b). two is one's descendant, return two.
  //     c). otherwise, return the lowest node with one and two in
  //         the two different subtrees.
  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode one, TreeNode two) {
    // Assumptions: root is not null,
    // one and two guaranteed to be in the tree and not null.
    if (root == null) {
      return null;
    }
    // if root is one or two, we can ignore the later recursions.
    if (root == one || root == two) {
      return root;
    }
    TreeNode ll = lowestCommonAncestor(root.left, one, two);
    TreeNode lr = lowestCommonAncestor(root.right, one, two);
    if (ll != null && lr != null) {
      return root;
    }
    return ll == null ? lr : ll;
  }
}

Back To Index

Class 11 - Bit Representation and Bit Operation
Determine If A Number Is Power Of 2
public class PowerOfTwo {
  // Method 1.
  public boolean isPowerOfTwoI(int number) {
    if (number <= 0) {
      return false;
    }
    // ignore all the trailing 0's,
    while ((number & 1) == 0) {
      number >>>= 1;
    }
    // check if the number is 1 at the end.
    return number == 1;
  }

  // Method 2.
  public boolean isPowerOfTwoII(int number) {
    if (number <= 0) {
      return false;
    }
    // count the number of 1's.
    int count = 0;
    while (number > 0) {
      count += number & 1;
      number >>>= 1;
    }
    // for a number of power of 2, there should be only one 1.
    return count == 1;
  }

  // Method 3
  public boolean isPowerOfTwoIII(int number) {
    // use the trick of number & (number - 1) will remove the rightmost 1.
    return number > 0 && (number & (number - 1)) == 0;
  }
}

Number Of Different Bits
public class NumberOfDiffBits {
  public int diffBits(int a, int b) {
    // after exclusive or, only the bits where a and b
    // are different will be 1.
    a ^= b;
    int count = 0;
    // In Java, notice that we are using logical right shift >>>.
    // and a != 0 as the terminate condition.
    while (a != 0) {
      count += a & 1;
      a >>>= 1;
    }
    return count;
  }
}

All Unique Characters II
/**
 * Determine if the letters in a word are all unique.
 * Assumption:
 * We are using ASCII encoding and the number of valid letters
 * is 256, encoded from 0 to 255.
 * The input word is not null.
 */
public class AllUniqueCharsII {
  public boolean allUnique(String word) {
    // each int value can represent 32 bit, so we need 8 ints
    // to represent 256 bits.
    int[] vec = new int[8];
    char[] array = word.toCharArray();
    for (char c : array) {
      // for a value c in the range of 0-255,
      // it is actually mapped to the int value at c/32 as index,
      // and the c%32'th bit of the int value.
      if ((vec[c / 32] >>> (c % 32) & 1) != 0) {
        return false;
      }
      vec[c / 32] |= 1 << (c % 32);
    }
    return true;
  }
}

Hexadecimal Representation
public class HexRepresentation {
  // Assumptions: number >= 0
  public String hex(int number) {
    String prefix = "0x";
    // handle the special case of 0 first.
    if (number == 0) {
      return prefix + "0";
    }
    // using StringBuilder so append operation is more efficient.
    StringBuilder sb = new StringBuilder();
    while (number > 0) {
      int rem = number % 16;
      if (rem < 10) {
        sb.append((char) ('0' + rem));
      } else {
        sb.append((char) (rem - 10 + 'A'));
      }
      number >>>= 4;
    }
    // reverse it at last so in all complexity is O(n).
    return prefix + sb.reverse().toString();
  }
}

Reverse Bits
public class ReverseBits {
  public int reverseI(int num) {
    for (int offset = 0; offset < 16; ++offset) {
      int right = (num >> offset) & 1;
      int left = (num >> (31 - offset)) & 1;
      if (left != right) {
        num ^= (1 << offset);
        num ^= (1 << (31 - offset));
      }
    }
    return num;
  }

  // merge sort way of reversing all the bits.
  public int reverseII(int num) {
    num = ((num & 0xFFFF0000) >>> 16) | ((num & 0x0000FFFF) << 16);
    num = ((num & 0xFF00FF00) >>> 8) | ((num & 0x00FF00FF) << 8);
    num = ((num & 0xF0F0F0F0) >>> 4) | ((num & 0x0F0F0F0F) << 4);
    num = ((num & 0xCCCCCCCC) >>> 2) | ((num & 0x33333333) << 2);
    num = ((num & 0xAAAAAAAA) >>> 1) | ((num & 0x55555555) << 1);
    return num;
  }
}

Back To Index

Class 12 - Dynamic Programming I
Longest Ascending Subarray
public class LongestAscendingSubArray {
  public int longest(int[] array) {
    // Assumptions: the given array is not null.
    if (array.length == 0) {
      return 0;
    }
    // dp[i] = 1           (array[i] <= array[i-1])
    //       = dp[i-1] + 1 (array[i] > array[i-1])
    // So we can make the space consumption more efficient by only
    // recording the latest dp[i].
    int result = 1;
    int cur = 1;
    for (int i = 1; i < array.length; i++) {
      if (array[i] > array[i - 1]) {
        // the second case, we can update dp[i].
        cur++;
        result = Math.max(result, cur);
      } else {
        // the first case, we need to reset dp[i].
        cur = 1;
      }
    }
    return result;
  }
}

Max Product Of Cutting Rope
public class MaxProductOfCuttingRope {
  public int maxProduct(int length) {
    // Assumptions: length >= 2.
    if (length == 2) {
      return 1;
    }
    int[] array = new int[length + 1];
    array[1] = 0;
    array[2] = 1;
    for (int i = 3; i < array.length; i++) {
      // At least one of the partitions after cutting is <= i/2,
      // so we can just pick that partition, and find the maximum product.
      for (int j = 1; j <= i / 2; j++) {
        // For the other partition, we can choose not cutting it or
        // cutting it, so the max number we can get is either i-j or array[i-j].
        array[i] = Math.max(array[i], j * Math.max(i - j, array[i - j]));
      }
    }
    return array[length];
  }
}

Array Hopper I
public class ArrayHopperI {
  // Method 1: DP, canJump[i] means from index 0, can jump to index i.
  public boolean canJump(int[] array) {
    // Assumptions: array is not null and is not empty.
    boolean[] canJump = new boolean[array.length];
    canJump[0] = true;
    for (int i = 1; i < array.length; i++) {
      for (int j = 0; j < i; j++) {
        // if index j is reachable from index 0, and from index j
        // it is possible to jump to index i.
        if (canJump[j] && array[j] + j >= i) {
          canJump[i] = true;
          break;
        }
      }
    }
    return canJump[array.length - 1];
  }

  // Method 2: DP, canJump[i] means from index i,
  // can jump to index array.length - 1.
  public boolean canJumpII(int[] array) {
    // Assumptions: array is not null and is not empty.
    if (array.length == 1) {
      return true;
    }
    boolean[] canJump = new boolean[array.length];
    for (int i = array.length - 2; i >= 0; i--) {
      // if from index i, it is already possible to jump
      // to the end of the array.
      if (i + array[i] >= array.length - 1) {
        canJump[i] = true;
      } else {
        // if any of the reachable indices from index i
        // is reachable to the end of the array.
        for (int j = array[i]; j >= 1; j--) {
          if (canJump[j + i]) {
            canJump[i] = true;
            break;
          }
        }
      }
    }
    return canJump[0];
  }

  // Method 3: Greedy solution.
  // Keep the max index reachable by jumping x steps, and
  // the max index reachable by jumping x+1 steps.
  public boolean canJumpIII(int[] array) {
    // Assumptions: array is not null and array.length >= 1.
    if (array.length == 1) {
      return true;
    }
    // the max index jumping current steps can reach.
    int cur = 0;
    // the max index jumping current + 1 steps can reach.
    int next = 0;
    for (int i = 0; i < array.length; i++) {
      if (i > cur) {
        // if i > cur, we can not use current steps to jump to i.
        if (cur == next) {
          // cur == next means there is no progress for
          // using current+1 jump steps, if that is the case,
          // we can never reach end of array.
          return false;
        }
        cur = next;
      }
      // update the max index jumping one more step can reach.
      next = Math.max(next, i + array[i]);
    }
    return true;
  }
}

Back To Index

Class 13 - Dynamic Programming II
Array Hopper II
public class ArrayHopperII {
  // Method 1: DP.
  public int minJump(int[] array) {
    // Assumptions: array is not null and is not empty.
    int length = array.length;
    // minJump record the min number of jumps from 0 to each of the indices.
    int[] minJump = new int[length];
    // we do not need to jump for index 0.
    minJump[0] = 0;
    for (int i = 1; i < length; i++) {
      minJump[i] = -1; // initialized as unreachable.
      for (int j = i - 1; j >= 0; j--) {
        if (j + array[j] >= i && minJump[j] != -1) {
          if (minJump[i] == -1 || minJump[i] > minJump[j] + 1) {
            minJump[i] = minJump[j] + 1;
          }
        }
      }
    }
    return minJump[length - 1];
  }

  // Method 2: Greedy solution.
  public int minJumpII(int[] array) {
    if (array.length == 1) {
      return 0;
    }
    // # of jumps currently.
    int jump = 0;
    // max index by current # of jumps.
    int cur = 0;
    // max index by current + 1 # of jumps.
    int next = 0;
    for (int i = 0; i < array.length; i++) {
      if (i > cur) {
        // if index i can not be reached by current # of jumps,
        // we need jump one more step.
        jump++;
        // if there is no progress by jumping one more step,
        // means it is unreachable.
        if (cur == next) {
          return -1;
        }
        cur = next;
      }
      next = Math.max(next, array[i] + i);
    }
    return jump;
  }
}

Largest Subarray Sum
public class LargestSubArraySum {
  public int largestSum(int[] array) {
    // Assumptions: array != null && length >= 1.
    // The subarray must contain at least one element.
    int result = array[0];
    int cur = array[0];
    // dp[i] means the largest sum of subarray ending at index i.
    // dp[i] = array[i]            if dp[i-1] <= 0
    //       = dp[i-1] + array[i]  if dp[i-1] > 0
    // So that we can reduce the space consumption by
    // recording the latest largest sum.
    for (int i = 1; i < array.length; i++) {
      cur = Math.max(cur + array[i], array[i]);
      result = Math.max(result, cur);
    }
    return result;
  }
}

Dictionary Word
public class DictionaryWord {
  public boolean canBreak(String input, String[] dict) {
    // Assumptions :
    // input is not null or empty.
    // dict is not null and dict is not empty,
    // all the strings in dict are not null or empty.
    Set<String> dictSet = toSet(dict);
    // Notice: sometimes it will be handy to have such index matching,
    // canBreak[i] represents index (i-1) in input, also
    // can represent the substring(0,i).
    boolean[] canBreak = new boolean[input.length() + 1];
    canBreak[0] = true;
    for (int i = 1; i < canBreak.length; i++) {
      for (int j = 0; j < i; j++) {
        if (dictSet.contains(input.substring(j, i)) && canBreak[j]) {
          canBreak[i] = true;
          break;
        }
      }
    }
    return canBreak[canBreak.length - 1];
  }

  private Set<String> toSet(String[] dict) {
    Set<String> set = new HashSet<>();
    for (String s : dict) {
      set.add(s);
    }
    return set;
  }
}

Edit Distance
public class EditDistance {
  public int editDistance(String one, String two) {
    // Assumptions: one,two are not null.
    // Again, using distance[i][j] to represent
    // substring(0,i) in one and substring(0,j) in two.
    int[][] distance = new int[one.length() + 1][two.length() + 1];
    for (int i = 0; i <= one.length(); i++) {
      for (int j = 0; j <= two.length(); j++) {
        if (i == 0) {
          distance[i][j] = j;
        } else if (j == 0) {
          distance[i][j] = i;
        } else if (one.charAt(i - 1) == two.charAt(j - 1)) {
          distance[i][j] = distance[i - 1][j - 1];
        } else {
          distance[i][j] = Math.min(distance[i - 1][j] + 1, distance[i][j - 1] + 1);
          distance[i][j] = Math.min(distance[i - 1][j - 1] + 1, distance[i][j]);
        }
      }
    }
    return distance[one.length()][two.length()];
  }
}

Largest Square Of “1” s
public class LargestSquareOfOnes {
  public int largest(int[][] matrix) {
    // Assumptions: The matrix is a binary matrix
    // (only contains 0 or 1 as the values),
    // it is not null, and has size N*N, N >= 0.
    int N = matrix.length;
    if (N == 0) {
      return 0;
    }
    int result = 0;
    // dp[i][j] means the largest square of 1's with right bottom
    // corner as matrix[i][j].
    int[][] largest = new int[N][N];
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < N; j++) {
        if (i == 0 || j == 0) {
          largest[i][j] = matrix[i][j] == 1 ? 1 : 0;
        } else if (matrix[i][j] == 1) {
          largest[i][j] = Math.min(largest[i][j - 1] + 1, largest[i - 1][j] + 1);
          largest[i][j] = Math.min(largest[i - 1][j - 1] + 1, largest[i][j]);
        }
        result = Math.max(result, largest[i][j]);
      }
    }
    return result;
  }
}

Back To Index

Class 15 - Dynamic Programming III
Longest Consecutive 1s
public class LongestOnes {
  public int longest(int[] array) {
    // Assumptions: array is not null.
    int result = 0;
    int cur = 0;
    for (int i = 0; i < array.length; i++) {
      if (array[i] == 1) {
        if (i == 0 || array[i - 1] == 0) {
          cur = 1;
        } else {
          cur++;
        }
        result = Math.max(result, cur);
      }
    }
    return result;
  }
}

Largest Cross With All “1”s
public class LargestCrossOfOnes {
  public int largest(int[][] matrix) {
    // Assumptions: matrix is not null, has size of N * M,
    // where N >= 0 and M >= 0.
    int N = matrix.length;
    if (N == 0) {
      return 0;
    }
    int M = matrix[0].length;
    if (M == 0) {
      return 0;
    }

    // leftup records the longest possible length for left and up
    // arms ending at each cells in the matrix.
    int[][] leftUp = leftUp(matrix, N, M);
    // rightdown records the longest possible length for right and down
    // arms ending at each cells in the matrix.
    int[][] rightDown = rightDown(matrix, N, M);
    // merge the two matrix by getting the min value for each cell,
    // and among all the cells get the max value.
    return merge(leftUp, rightDown, N, M);
  }

  // merge leftup and rightdown matrix into leftup,
  // the value of each cell is the min value of the corresponding cells
  // in the two matrix, also it returns the max value among all the cells
  // in the merged matrix.
  private int merge(int[][] leftUp, int[][] rightDown, int N, int M) {
    int result = 0;
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < M; j++) {
        leftUp[i][j] = Math.min(leftUp[i][j], rightDown[i][j]);
        result = Math.max(result, leftUp[i][j]);
      }
    }
    return result;
  }

  // calculate the max possible length of left and up arms
  // for each of the cells in the matrix.
  private int[][] leftUp(int[][] matrix, int N, int M) {
    int[][] left = new int[N][M];
    int[][] up = new int[N][M];
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < M; j++) {
        if (matrix[i][j] == 1) {
          if (i == 0 && j == 0) {
            up[i][j] = 1;
            left[i][j] = 1;
          } else if (i == 0) {
            up[i][j] = 1;
            left[i][j] = left[i][j - 1] + 1;
          } else if (j == 0) {
            up[i][j] = up[i - 1][j] + 1;
            left[i][j] = 1;
          } else {
            up[i][j] = up[i - 1][j] + 1;
            left[i][j] = left[i][j - 1] + 1;
          }
        }
      }
    }
    // merge left and up, return the merged matrix.
    merge(left, up, N, M);
    return left;
  }

  // calculate the max possible length of right and down arms
  // for each of the cells in the matrix.
  private int[][] rightDown(int[][] matrix, int N, int M) {
    int[][] right = new int[N][M];
    int[][] down = new int[N][M];
    for (int i = N - 1; i >= 0; i--) {
      for (int j = M - 1; j >= 0; j--) {
        if (matrix[i][j] == 1) {
          if (i == N - 1 && j == M - 1) {
            down[i][j] = 1;
            right[i][j] = 1;
          } else if (i == N - 1) {
            down[i][j] = 1;
            right[i][j] = right[i][j + 1] + 1;
          } else if (j == M - 1) {
            down[i][j] = down[i + 1][j] + 1;
            right[i][j] = 1;
          } else {
            down[i][j] = down[i + 1][j] + 1;
            right[i][j] = right[i][j + 1] + 1;
          }
        }
      }
    }
    // merge right and down, return the merged matrix.
    merge(right, down, N, M);
    return right;
  }
}

Largest X With All “1”s
public class LargestXOfOnes {
  public int largest(int[][] matrix) {
    // Assumptions: matrix is not null, has size of N * M,
    // N >= 0 and M >= 0.
    int N = matrix.length;
    if (N == 0) {
      return 0;
    }
    int M = matrix[0].length;
    if (M == 0) {
      return 0;
    }
    int[][] leftUp = leftUp(matrix, N, M);
    int[][] rightDown = rightDown(matrix, N, M);
    return merge(leftUp, rightDown, N, M);
  }

  private int merge(int[][] leftUp, int[][] rightDown, int N, int M) {
    int result = 0;
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < M; j++) {
        leftUp[i][j] = Math.min(leftUp[i][j], rightDown[i][j]);
        result = Math.max(result, leftUp[i][j]);
      }
    }
    return result;
  }

  private int[][] leftUp(int[][] matrix, int N, int M) {
    int[][] left = new int[N][M];
    int[][] up = new int[N][M];
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < M; j++) {
        if (matrix[i][j] == 1) {
          left[i][j] = getNumber(left, i - 1, j - 1, N, M) + 1;
          up[i][j] = getNumber(up, i - 1, j + 1, N, M) + 1;
        }
      }
    }
    merge(left, up, N, M);
    return left;
  }

  private int[][] rightDown(int[][] matrix, int N, int M) {
    int[][] right = new int[N][M];
    int[][] down = new int[N][M];
    for (int i = N - 1; i >= 0; i--) {
      for (int j = M - 1; j >= 0; j--) {
        if (matrix[i][j] == 1) {
          right[i][j] = getNumber(right, i + 1, j + 1, N, M) + 1;
          down[i][j] = getNumber(down, i + 1, j - 1, N, M) + 1;
        }
      }
    }
    merge(right, down, N, M);
    return right;
  }

  private int getNumber(int[][] number, int x, int y, int N, int M) {
    if (x < 0 || x >= N || y < 0 || y >= M) {
      return 0;
    }
    return number[x][y];
  }
}

Given a matrix where every element is either ‘0’ or ‘1’, find the largest subsquare surrounded by ‘1’.
public class LargestSquareSurroundedOne {
  public class LargestSquareSurroundedByOne {
    // Return the length of the largest square.
    public int largest(int[][] matrix) {
      // Assumptions: matrix is not null, size of M * N, where M, N >= 0
      // the elements in the matrix are either 0 or 1.
      if (matrix.length == 0 || matrix[0].length == 0) {
        return 0;
      }
      int result = 0;
      int M = matrix.length;
      int N = matrix[0].length;
      // the longest left arm length ending at each position in the matrix.
      // we here apply a trick for ease of later processing:
      // left[i][j] is actually mapped to matrix[i - 1][j - 1],
      // this will reduced the corner cases.
      int[][] left = new int[M + 1][N + 1];
      int[][] up = new int[M + 1][N + 1];
      for (int i = 0; i < M; i++) {
        for (int j = 0; j < N; j++) {
          if (matrix[i][j] == 1) {
            left[i + 1][j + 1] = left[i + 1][j] + 1;
            up[i + 1][j + 1] = up[i][j + 1] + 1;
            // the maximum length of a surrounded by 1 matrix with rightbottom
            // position at matrix[i][j] is determined by the min value of
            // left[i+1][j+1] and up[i+1][j+1],
            // and we check one by one all the possible lengths if it can
            // provide the actual matrix.
            // we only need to check the longest left arm length of the righttop
            // cell and the longest up arm length of the leftbottom cell.
            for (int maxLength = Math.min(left[i + 1][j + 1], up[i + 1][j + 1]); maxLength >= 1; maxLength--) {
              if (left[i + 2 - maxLength][j + 1] >= maxLength && up[i + 1][j + 2 - maxLength] >= maxLength) {
                result = Math.max(result, maxLength);
                break;
              }
            }
          }
        }
      }
      return result;
    }
  }
}

Largest Submatrix Sum
public class LargestSubMatrixSum {
  public int largest(int[][] matrix) {
    // Assumptions: matrix is not null, has size N * M and N, M >= 1.
    int N = matrix.length;
    int M = matrix[0].length;
    int result = Integer.MIN_VALUE;
    for (int i = 0; i < N; i++) {
      int[] cur = new int[M];
      for (int j = i; j < N; j++) {
        // for each row i, we add the rows one by one for row j,
        // to make sure each time we only introduce O(n) time.
        add(cur, matrix[j]);
        // for each possible pair of rows i,j,
        // we would like to know what is the largest submatrix sum
        // using top row as row i and bottom row as row j.
        // we "flatten" these area to a one dimensional array.
        result = Math.max(result, max(cur));
      }
    }
    return result;
  }

  private void add(int[] cur, int[] add) {
    for (int i = 0; i < cur.length; i++) {
      cur[i] += add[i];
    }
  }

  // largest subarray sum.
  private int max(int[] cur) {
    int result = cur[0];
    int tmp = cur[0];
    for (int i = 1; i < cur.length; i++) {
      tmp = Math.max(tmp + cur[i], cur[i]);
      result = Math.max(result, tmp);
    }
    return result;
  }
}

Back To Index

Class 16 - Probability, Sampling, Randomization
Shuffle
public class PerfectShuffle {
  public void shuffle(int[] array) {
    // Assumptions: array is not null.
    if (array.length <= 1) {
      return;
    }
    // from right to left,
    // for index i-1, randomly pick one of the first i elements.
    for (int i = array.length; i >= 1; i--) {
      int idx = (int) (Math.random() * i);
      swap(array, i - 1, idx);
    }
  }

  private void swap(int[] array, int left, int right) {
    int tmp = array[left];
    array[left] = array[right];
    array[right] = tmp;
  }
}

Reservoir Sampling
// This class will be used as a reader and it read each of
// the element by calling the read() method.
// by calling the sample() method, it will return the sample
// of whatever read before.
public class ReservoirSampling {
  // how many numbers have been read so far.
  private int count;
  // only need to maintain the current sample.
  private Integer sample;

  public ReservoirSampling() {
    // initialization, count is initialized as 0 since there is
    // no single number read at the beginning.
    this.count = 0;
    this.sample = null;
  }

  public void read(int value) {
    count++;
    int prob = (int) (Math.random() * count);
    // the current read value has the probability of 1 / count to be as the
    // current sample.
    if (prob == 0) {
      sample = value;
    }
  }

  public Integer sample() {
    return sample;
  }
}

Reservoir Sampling With K Samples
public class GeneralizedReservoirSampling {
  private final int k;
  private int count;
  private List<Integer> sample;

  public GeneralizedReservoirSampling(int k) {
    // we need to sample k elements instead of just one element.
    // usually we will need this validation in the constructor.
    if (k <= 0) {
      throw new IllegalArgumentException("k must be > 0");
    }
    this.k = k;
    this.count = 0;
    sample = new ArrayList<Integer>();
  }

  public void read(int value) {
    count++;
    if (count <= k) {
      // for the first k elements, we just add them into the sample list.
      sample.add(value);
    } else {
      int random = (int) (Math.random() * count);
      // for the recent read element, it should have the probability of
      // k / count to be as one of the samples.
      if (random < k) {
        // replace the sample at the corresponding position.
        sample.set(random, value);
      }
    }
  }

  public List<Integer> sample() {
    return sample;
  }
}

Random7 Using Random5
public class RandomSeven {
  // On laicode.com, you can directly call RandomFive.random5() to
  // get a random number in the range of 0-4.
  public int random7() {
    while (true) {
      // to generate a uniformly distributed 0-24 number.
      int random = 5 * RandomFive.random5() + RandomFive.random5();
      // we only care about the first 21 numbers and should
      // ignore and try again for the numbers >= 21.
      if (random < 21) {
        return random % 7;
      }
    }
  }
}

Random1000 Using Random5
public class Solution {
  public int random1000() {
    while (true) {
      // The following 4 lines of code is usually used to compute
      // a0*x^0 + a1*x^1 + a2*x^2 + a3*x^3 + … + ak*x^k
      int num = 0;
      for (int i = 0; i < 5; i++) {
        num = num * 5 + RandomFive.random5();
      }
      // choose 3000 instead of 1000 to reduce the # of expected random5() calls.
      if (num < 3000) {
       return num % 1000;
      }
    }
  }
}

Median Tracker Of Data Flow
// MedianTracker will call read() method to read the values one by one.
public class MedianTracker {
  private PriorityQueue<Integer> smallerHalf;
  private PriorityQueue<Integer> largerHalf;

  public MedianTracker() {
    // We care about the smallest number of the larger half and
    // largest number of the smaller half.
    // So for the smaller half we use a max heap and for the
    // larger half we use a min heap.
    largerHalf = new PriorityQueue<Integer>();
    smallerHalf = new PriorityQueue<Integer>(11, Collections.reverseOrder());
  }

  public void read(int value) {
    // We maintain the property:
    // size(smallerHalf) == size(largerHalf) when there are even number of
    // values read, or size(smallerHalf) == size(largerHalf) + 1, when
    // there are odd number of values read.
    if (smallerHalf.isEmpty() || value <= smallerHalf.peek()) {
      smallerHalf.offer(value);
    } else {
      largerHalf.offer(value);
    }
    // After we insert the value,
    // only when size(smallerHalf) == size(largeHalf) + 2 or
    // size(smallerHalf) == size(largeHalf) - 1 will break the balance,
    // and we need to do the adjustment accordingly.
    if (smallerHalf.size() - largerHalf.size() >= 2) {
      largerHalf.offer(smallerHalf.poll());
    } else if (largerHalf.size() > smallerHalf.size()) {
      smallerHalf.offer(largerHalf.poll());
    }
  }

  public Double median() {
    int size = size();
    // By the property we maintained, it is easy to know that
    // if the number of values read is odd, the largest one in
    // the smaller half is the median.
    if (size == 0) {
      return null;
    } else if (size % 2 != 0) {
      return (double) (smallerHalf.peek());
    } else {
      return (smallerHalf.peek() + largerHalf.peek()) / 2.0;
    }
  }

  private int size() {
    return smallerHalf.size() + largerHalf.size();
  }
}

95th Percentile
public class NinetyFivePercentile {
  public int percentile95(List<Integer> lengths) {
    // Assumptions: lengths is not null and size >= 1 without
    // any null values.
    // The length of possible longest url is 4096.
    int[] count = new int[4097];
    for (int len : lengths) {
      count[len]++;
    }
    int sum = 0;
    int len = 4097;
    while (sum <= 0.05 * lengths.size()) {
      sum += count[--len];
    }
    return len;
  }
}

Back To Index

Class 18 - 加强练习 I
Array Deduplication I(sorted array, duplicate element only retain one)
public class ArrayDeduplicationI {
  public int[] dedup(int[] array) {
    // Assumptions: array is not null.
    if (array.length <= 1) {
      return array;
    }
    // slow pointer starts from 0 and array[0] is always valid.
    // slow pointer is "included" in the valid partition.
    int end = 0;
    for (int i = 1; i < array.length; i++) {
      // for any duplicate elements, we just ignore.
      if (array[i] != array[end]) {
        array[++end] = array[i];
      }
    }
    // Notice: usually you don't have to copy the subarray, instead,
    // you can just return the length of valid subarray after dedup
    // since the operation is done in place.
    // this is only useful for laicode to validate the result.
    return Arrays.copyOf(array, end + 1);
  }
}

Array Deduplication II(sorted array, duplicate element only retain two)
public class ArrayDeduplicationII {
  public int[] dedup(int[] array) {
    // Assumptions: array is not null.
    if (array.length <= 2) {
      return array;
    }
    int end = 1;
    for (int i = 2; i < array.length; i++) {
      // Notice: we can do this because it is a sorted array, and
      // array[i] == array[end - 1] implies that
      // array[end - 1] == array[end] == array[i].
      // if it is not a sorted array we need to find other way out.
      if (array[i] != array[end - 1]) {
        array[++end] = array[i];
      }
    }
    return Arrays.copyOf(array, end + 1);
  }
}

Array Deduplication III(sorted array, duplicate element not retain any)
public class ArrayDeduplicationIII {
  public int[] dedup(int[] array) {
    // Assumptions: array is not null.
    if (array == null || array.length <= 1) {
      return array;
    }
    int end = 0;
    // use flag to see if there is any duplicates of array[end].
    boolean flag = false;
    for (int i = 1; i < array.length; i++) {
      if (array[i] == array[end]) {
        // if there is duplicate, set flag and do nothing.
        flag = true;
      } else if (flag == true) {
        // if array[i] != array[end], and flag is set,
        // array[end] should not be included in the valid subarray,
        // and we can just replace it with array[i] since next
        // we are going to check if there is any duplicate of array[i].
        array[end] = array[i];
        // reset flag to false since we are processing another element now.
        flag = false;
      } else {
        // if array[i] != array[end] and flag is not set,
        // it means there is no duplicate of array[end] and it should be
        // included in the valid subarray.
        array[++end] = array[i];
      }
    }
    // do not forget that we need to check if there is any duplicates for
    // the last array[end].
    return Arrays.copyOf(array, flag ? end : end + 1);
  }
}

Array Deduplication IV(unsorted array, repeatedly deduplication)
public class ArrayDeduplicationIV {
  public int[] dedup(int[] array) {
    // Assumptions: array is not null.
    int end = -1;
    for (int i = 0; i < array.length; i++) {
      // we are using the left part of the original array as a stack.
      // and the top element's index is end. if the stack is empty(end == -1),
      // we just push the element into the stack, or if the element is not
      // the same as the top element of the stack, we can push he element into
      // the stack as well.
      if (end == -1 || array[end] != array[i]) {
        array[++end] = array[i];
      } else {
        // otherwise, we ignore all consecutive duplicates and
        // remove the top element of the stack.
        while (i + 1 < array.length && array[i + 1] == array[end]) {
          i++;
        }
        end--;
      }
    }
    return Arrays.copyOf(array, end + 1);
  }
}

Move 0s To The End II
/**
 * Move 0s to the right end of the array, the relative order of the elements
 * in the original array must be maintained.
 */
public class MoveZeroII {
  public int[] moveZero(int[] array) {
    // Assumptions: array is not null.
    if (array.length <= 1) {
      return array;
    }
    // the slow pointer is not included in the non-zero subarray.
    int end = 0;
    for (int i = 0; i < array.length; i++) {
      if (array[i] != 0) {
        array[end++] = array[i];
      }
    }
    // fill in the right part with 0.
    for (int i = end; i < array.length; i++) {
      array[i] = 0;
    }
    return array;
  }
}

Largest And Smallest
public class LargestAndSmallest {
  public int[] largestAndSmallest(int[] array) {
    // Assumptions: array is not null & array.length >=1.
    int n = array.length;
    // indices (x, n - 1 - x) will be paired up, the larger numbers of
    // each pair will be put on the left side, so after the comparisons,
    // The left half of the array are the larger values for each pairs,
    // the right half of the array are the smaller values for each pairs.
    for (int i = 0; i < n / 2; i++) {
      if (array[i] < array[n - 1 - i]) {
        swap(array, i, n - 1 - i);
      }
    }
    // The largest value should be the largest of the left half,
    // The smallest value should be the smallest of the right half.
    return new int[] { largest(array, 0, (n - 1) / 2), smallest(array, n / 2, n - 1) };
  }

  private int largest(int[] array, int left, int right) {
    int largest = array[left];
    for (int i = left + 1; i <= right; i++) {
      largest = Math.max(largest, array[i]);
    }
    return largest;
  }

  private int smallest(int[] array, int left, int right) {
    int smallest = array[left];
    for (int i = left + 1; i <= right; i++) {
      smallest = Math.min(smallest, array[i]);
    }
    return smallest;
  }

  private void swap(int[] array, int i, int j) {
    int tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
  }
}

Largest And Second Largest
public class LargestAndSecondLargest {
  // The Element class will be used to store the original value
  // in the array and all the values compared to it.
  static class Element {
    int value;
    List<Integer> compredValues;

    Element(int value) {
      this.value = value;
      this.compredValues = new ArrayList<>();
    }
  }

  public int[] largestAndSecond(int[] array) {
    // Assumptions: array is not null, array.length >= 2.
    // Convert the original array to Element array.
    Element[] helper = convert(array);
    // largerLength is the left partition's length containing the
    // larger values after each round of comparison.
    // For each round, the comparison is still doing for each of
    // the indices pairs (i, largerLength - 1 - i).
    // So that the larger elements are always on the left side,
    // and the largerLength will be cut in half each round.
    // largerLength is obviously initiated by the array's length.
    int largerLength = array.length;
    // We will terminate when there is only one element left on
    // the larger partition, and it has to be the largest value.
    // the second largest value is the largest value in its
    // compared values.
    while (largerLength > 1) {
      compareAndSwap(helper, largerLength);
      largerLength = (largerLength + 1) / 2;
    }
    return new int[] { helper[0].value, largest(helper[0].compredValues) };
  }

  private Element[] convert(int[] array) {
    Element[] helper = new Element[array.length];
    for (int i = 0; i < array.length; i++) {
      helper[i] = new Element(array[i]);
    }
    return helper;
  }

  // Compare each of the indices pairs (i, largerLength - 1 - i),
  // swap the larger values on the left side if necessary,
  // and put the smaller value into the larger value's compare values list.
  private void compareAndSwap(Element[] helper, int largerLength) {
    for (int i = 0; i < largerLength / 2; i++) {
      if (helper[i].value < helper[largerLength - 1 - i].value) {
        swap(helper, i, largerLength - 1 - i);
      }
      helper[i].compredValues.add(helper[largerLength - 1 - i].value);
    }
  }

  private void swap(Element[] helper, int left, int right) {
    Element tmp = helper[left];
    helper[left] = helper[right];
    helper[right] = tmp;
  }

  private int largest(List<Integer> list) {
    // This is guaranteed to be O(1).
    int max = list.get(0);
    // Using Iterator is guaranteed to be O(1) traversing each of the
    // elements in the list.
    for (int num : list) {
      max = Math.max(max, num);
    }
    return max;
  }
}

Rotate Matrix By 90 Degree Clockwise
public class RotateMatrix {
  // Method 1: Split into levels and for each level split it into
  // four partitions.
  public void rotate(int[][] matrix) {
    // Assumptions: matrix is not null and has size of N * N, N >= 0.
    int n = matrix.length;
    if (n <= 1) {
      return;
    }
    int round = n / 2;
    for (int level = 0; level < round; level++) {
      int left = level;
      int right = n - 2 - level;
      for (int i = left; i <= right; i++) {
        int tmp = matrix[left][i];
        matrix[left][i] = matrix[n - 1 - i][left];
        matrix[n - 1 - i][left] = matrix[n - 1 - left][n - 1 - i];
        matrix[n - 1 - left][n - 1 - i] = matrix[i][n - 1 - left];
        matrix[i][n - 1 - left] = tmp;
      }
    }
  }

  // Method 2: Rotate a point by 90 degree clockwise ==
  // 1. Mirror the point according to y axis, then
  // 2. Mirror the point according the line of y = x.
  public void rotateII(int[][] matrix) {
    int n = matrix.length;
    if (n <= 1) {
      return;
    }
    mirrorY(matrix, n);
    mirrorYEX(matrix, n);
  }

  // mirror the point by y axis.
  private void mirrorY(int[][] matrix, int n) {
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n / 2; j++) {
        swap(matrix, i, j, i, n - 1 - j);
      }
    }
  }

  // mirror the point by the line of y = x.
  private void mirrorYEX(int[][] matrix, int n) {
    for (int i = 0; i < n; i++) {
      for (int j = 0; j + i < n - 1; j++) {
        swap(matrix, i, j, n - 1 - j, n - 1 - i);
      }
    }
  }

  private void swap(int[][] matrix, int iRow, int iCol, int jRow, int jCol) {
    int tmp = matrix[iRow][iCol];
    matrix[iRow][iCol] = matrix[jRow][jCol];
    matrix[jRow][jCol] = tmp;
  }
}

Zig-Zag Order Print Binary Tree
public class ZigZagLayerByLayer {
  public List<Integer> zigZag(TreeNode root) {
    if (root == null) {
      return new LinkedList<Integer>();
    }
    Deque<TreeNode> deque = new LinkedList<TreeNode>();
    List<Integer> list = new LinkedList<Integer>();
    deque.offerFirst(root);
    int layer = 0;
    while (!deque.isEmpty()) {
      // The size of current level should be extracted at the first place,
      // because the size of the deque is changing all the time.
      int size = deque.size();
      for (int i = 0; i < size; i++) {
        if (layer == 0) {
          // at even layer, from right to left.
          TreeNode tmp = deque.pollLast();
          list.add(tmp.key);
          if (tmp.right != null) {
            deque.offerFirst(tmp.right);
          }
          if (tmp.left != null) {
            deque.offerFirst(tmp.left);
          }
        } else {
          // at odd layer, from left to right.
          TreeNode tmp = deque.pollFirst();
          list.add(tmp.key);
          if (tmp.left != null) {
            deque.offerLast(tmp.left);
          }
          if (tmp.right != null) {
            deque.offerLast(tmp.right);
          }
        }
      }
      layer = 1 - layer;
    }
    return list;
  }
}

Lowest Common Ancestor Of K Nodes
public class LCAIV {
  public TreeNode lowestCommonAncestor(TreeNode root, List<TreeNode> nodes) {
    // Assumptions: the list of nodes is not null or not empty,
    // all the nodes in the list are guaranteed to be in the tree.
    Set<TreeNode> set = new HashSet<>(nodes);
    return helper(root, set);
  }

  private TreeNode helper(TreeNode root, Set<TreeNode> set) {
    if (root == null) {
      return null;
    }
    if (set.contains(root)) {
      return root;
    }
    TreeNode l = helper(root.left, set);
    TreeNode r = helper(root.right, set);
    if (l != null && r != null) {
      return root;
    }
    return l != null ? l : r;
  }
}

Lowest Common Ancestor(with parent pointer)
public class LCAII {
  public TreeNodeP lowestCommonAncestor(TreeNodeP one, TreeNodeP two) {
    int l1 = length(one);
    int l2 = length(two);
    // This is a small trick that can guarantee when calling mergeNode(),
    // the first list is the shorter list, the second list is the longer one.
    if (l1 <= l2) {
      return mergeNode(one, two, l2 - l1);
    } else {
      return mergeNode(two, one, l1 - l2);
    }
  }

  private TreeNodeP mergeNode(TreeNodeP shorter, TreeNodeP longer, int diff) {
    while (diff > 0) {
      longer = longer.parent;
      diff--;
    }
    while (longer != shorter) {
      longer = longer.parent;
      shorter = shorter.parent;
    }
    return longer;
  }

  // get the length of the list from the node to the root of the tree
  // along the path using parent pointers.
  private int length(TreeNodeP node) {
    int length = 0;
    while (node != null) {
      length++;
      node = node.parent;
    }
    return length;
  }
}

Sort In Specified Order
public class Solution {
  static class MyComparator implements Comparator<Integer> {
    private Map<Integer, Integer> map;
    public MyComparator(int[] array) {
      map = new HashMap<>();
      for (int i = 0; i < array.length; i++) {
        map.put(array[i], i);
      }
    }

    @Override
    public int compare(Integer i1, Integer i2) {
      Integer index1 = map.get(i1);
      Integer index2 = map.get(i2);
      if (index1 != null && index2 != null) {
        return index1.compareTo(index2);
      } else if (index1 == null && index2 == null) {
        return i1.compareTo(i2);
      }
      return index1 != null ? -1 : 1;
    }
  }
  public int[] sortSpecial(int[] A1, int[] A2) {
    Integer[] refArray = toIntegerArray(A1);
    Arrays.sort(refArray, new MyComparator(A2));
    toIntArray(refArray, A1);
    return A1;
  }

  private void toIntArray(Integer[] array, int[] result) {
    for (int i = 0; i < array.length; i++) {
      result[i] = array[i];
    }
  }
  
  private Integer[] toIntegerArray(int[] array) {
    Integer[] result = new Integer[array.length];
    for (int i = 0; i < array.length; i++) {
      result[i] = array[i];
    }
    return result;
  }
}

Back To Index

Class 20 - Midterm II
Maximum Path Sum Binary Tree I(from one leaf node to another leaf)
public class MaxPathSumBinaryTreeI {
  public int maxPathSum(TreeNode root) {
    // we can wrap a global variable into an array so that
    // we can change the value during recursion.
    int[] max = new int[] { Integer.MIN_VALUE };
    maxSumHelper(root, max);
    return max[0];
  }

  // the returned value is the max path sum from
  // root to any leaf node in its subtree.
  private int maxSumHelper(TreeNode root, int[] max) {
    if (root == null) {
      return 0;
    }
    int left = maxSumHelper(root.left, max);
    int right = maxSumHelper(root.right, max);
    // only when root node has both left and right child,
    // we need to possibly update the max path sum.
    if (root.left != null && root.right != null) {
      max[0] = Math.max(max[0], left + right + root.key);
      return Math.max(left, right) + root.key;
    }
    return root.left == null ? right + root.key : left + root.key;
  }
}

Min Cuts Of Palindrome Partitions
public class MinimumCutsPalindromes {
  public int minCuts(String input) {
    // Assumptions: input is not null.
    char[] array = input.toCharArray();
    int len = array.length;
    if (len == 0) {
      return 0;
    }
    // isP[i][j] indicates if the substring (i-1,j-1) is palindrome.
    boolean[][] isP = new boolean[len + 1][len + 1];
    // minCuts[i] indicates the min cuts for substring (0,i-1).
    int[] minCuts = new int[len + 1];
    for (int end = 1; end <= len; end++) {
      // initialization of minCuts[end], we at most need end cuts
      // (separate all the characters).
      minCuts[end] = end;
      for (int start = end; start >= 1; start--) {
        // calculate isP[start][end] first.
        if (array[start - 1] == array[end - 1]) {
          isP[start][end] = end - start < 2 || isP[start + 1][end - 1];
        }
        // use isP[start][end] to calculate minCuts[end].
        if (isP[start][end]) {
          minCuts[end] = Math.min(minCuts[end], 1 + minCuts[start - 1]);
        }
      }
    }
    return minCuts[len] - 1;
  }
}

Valid If Blocks
class Solution {  
  public void validIfBlocks(int n) {
    if (n <= 0) {
      return;
    }
    List<String> blocks = new ArrayList<String>();
    helper(blocks, n, n);
  }
  
  private void helper(List<String> blocks, int left, int right) {
    if (left == 0 && right == 0) {
      print(blocks);
      return;
    }
    StringBuilder builder = new StringBuilder();
    if (left > 0) {
      for (int i = 0; i < right - left; i++) {
        builder.append("  ");
      }
      blocks.add(builder.append("if {").toString());
      helper(blocks, left - 1, right);
      blocks.remove(blocks.size() - 1);
    }
    builder.setLength(0);
    if (right > left) {
      for (int i = 0; i < right - left - 1; i++) {
        builder.append("  ");
      }
      blocks.add(builder.append("}").toString());
      helper(blocks, left, right - 1);
      blocks.remove(blocks.size() - 1);
    }
  }
  
  private void print(List<String> blocks) {
    for (String s : blocks) {
      System.out.println(s);
    }
    System.out.println("=================================");
  }
}

Back To Index

Class 21 - 强化练习 II
Deep Copy Linked List With Random Pointer
public class DeepCopyLinkedListRandom {
  // Method 1: using HashMap to avoid copy multiple times for the same node.
  public RandomListNode copy(RandomListNode head) {
    if (head == null) {
      return null;
    }
    // Sentinel node to help construct the deep copy.
    RandomListNode dummy = new RandomListNode(0);
    RandomListNode cur = dummy;
    // Maintains the mapping between the node in the original list and
    // the corresponding node in the new list.
    Map<RandomListNode, RandomListNode> map = new HashMap<>();
    while (head != null) {
      // Copy the current node if necessary.
      if (!map.containsKey(head)) {
        map.put(head, new RandomListNode(head.value));
      }
      // Connect the copied node to the deep copy list.
      cur.next = map.get(head);
      // Copy the random node if necessary.
      if (head.random != null) {
        if (!map.containsKey(head.random)) {
          map.put(head.random, new RandomListNode(head.random.value));
        }
        // Connect the copied node to the random pointer.
        cur.next.random = map.get(head.random);
      }
      head = head.next;
      cur = cur.next;
    }
    return dummy.next;
  }

  // Method 2: Another three pass solution, not using HashMap,
  // but changing the original list structure during the copy
  // (it will be changed back at the end).
  public RandomListNode copyII(RandomListNode head) {
    if (head == null) {
      return null;
    }
    // First pass, for each node in the original list, insert a
    // copied node between the node and node.next.
    RandomListNode cur = head;
    while (cur != null) {
      // Make a copy of cur node, insert it to the middle of cur and cur.next.
      RandomListNode copy = new RandomListNode(cur.value);
      copy.next = cur.next;
      cur.next = copy;
      cur = cur.next.next;
    }
    // Second pass, link the random pointer for the copied node.
    cur = head;
    while (cur != null) {
      if (cur.random != null) {
        cur.next.random = cur.random.next;
      }
      cur = cur.next.next;
    }
    // Third pass, extract the copied node.
    cur = head;
    RandomListNode dummy = new RandomListNode(0);
    RandomListNode copyPrev = dummy;
    while (cur != null) {
      copyPrev.next = cur.next;
      cur.next = cur.next.next;
      copyPrev = copyPrev.next;
      cur = cur.next;
    }
    return dummy.next;
  }
}

Deep Copy Of Graph(with possible cycles)
public class DeepCopyUGraph {
  public List<GraphNode> copy(List<GraphNode> graph) {
    if (graph == null) {
      return null;
    }
    HashMap<GraphNode, GraphNode> map = new HashMap<GraphNode, GraphNode>();
    for (GraphNode node : graph) {
      if (!map.containsKey(node)) {
        map.put(node, new GraphNode(node.key));
        DFS(node, map);
      }
    }
    return new ArrayList<GraphNode>(map.values());
  }

  private void DFS(GraphNode seed, HashMap<GraphNode, GraphNode> map) {
    GraphNode copy = map.get(seed);
    for (GraphNode nei : seed.neighbors) {
      if (!map.containsKey(nei)) {
        map.put(nei, new GraphNode(nei.key));
        DFS(nei, map);
      }
      copy.neighbors.add(map.get(nei));
    }
  }
}

Merge K Sorted Arrays
public class MergeKSortedArray {
  public int[] merge(int[][] arrayOfArrays) {
    // Assumptions: arrayOfArrays is not null, none of the array is null either.
    PriorityQueue<Entry> minHeap = new PriorityQueue<Entry>(11, new MyComparator());
    int length = 0;
    for (int i = 0; i < arrayOfArrays.length; i++) {
      int[] array = arrayOfArrays[i];
      length += array.length;
      if (array.length != 0) {
        // We use two index to record the position of each element:
        // the index of the array in the arrayOfArrays,
        // the index of the element in the array.
        minHeap.offer(new Entry(i, 0, array[0]));
      }
    }
    int[] result = new int[length];
    int cur = 0;
    while (!minHeap.isEmpty()) {
      Entry tmp = minHeap.poll();
      result[cur++] = tmp.value;
      if (tmp.y + 1 < arrayOfArrays[tmp.x].length) {
        // reuse the same Entry object but advance the index by 1.
        tmp.y++;
        tmp.value = arrayOfArrays[tmp.x][tmp.y];
        minHeap.offer(tmp);
      }
    }
    return result;
  }

  static class MyComparator implements Comparator<Entry> {
    @Override
    public int compare(Entry e1, Entry e2) {
      if (e1.value == e2.value) {
        return 0;
      }
      return e1.value < e2.value ? -1 : 1;
    }
  }

  static class Entry {
    // The row number.
    int x;
    // The column number.
    int y;
    // The corresponding value.
    int value;

    Entry(int x, int y, int value) {
      this.x = x;
      this.y = y;
      this.value = value;
    }
  }
}

Merge K Sorted Lists
public class MergeKSortedList {
  public ListNode merge(List<ListNode> listOfLists) {
    // Assumptions: listOfLists is not null, none of the lists is null.
    PriorityQueue<ListNode> minHeap = new PriorityQueue<ListNode>(11, new MyComparator());
    ListNode dummy = new ListNode(0);
    ListNode cur = dummy;
    for (ListNode node : listOfLists) {
      if (node != null) {
        minHeap.offer(node);
      }
    }
    while (!minHeap.isEmpty()) {
      cur.next = minHeap.poll();
      if (cur.next.next != null) {
        minHeap.offer(cur.next.next);
      }
      cur = cur.next;
    }
    return dummy.next;
  }

  static class MyComparator implements Comparator<ListNode> {
    @Override
    public int compare(ListNode o1, ListNode o2) {
      if (o1.value == o2.value) {
        return 0;
      }
      return o1.value < o2.value ? -1 : 1;
    }
  }
}

Closest Number In Binary Search Tree
public class ClosestNumberBST {
  public int closest(TreeNode root, int target) {
    // Assumptions: the given binary search tree is not null.
    int result = root.key;
    // The closest number has to be on the path of finding
    // the target value in the binary search tree.
    while (root != null) {
      if (root.key == target) {
        return root.key;
      } else {
        if (Math.abs(root.key - target) < Math.abs(result - target)) {
          result = root.key;
        }
        if (root.key < target) {
          root = root.right;
        } else {
          root = root.left;
        }
      }
    }
    return result;
  }
}

Binary Search Tree Largest Number Smaller Than Target
public class LargestNumberSmallerBST {
  public int largestSmaller(TreeNode root, int target) {
    // Assumptions: the binary search tree is not null.
    int result = Integer.MIN_VALUE;
    while (root != null) {
      if (root.key >= target) {
        root = root.left;
      } else {
        // the candidates are all the nodes on the path of
        // searching for target, which is smaller than target.
        // and notice that, the later searched node has lager
        // value than the earlier searched ones.
        result = root.key;
        root = root.right;
      }
    }
    return result;
  }
}

Binary Search Tree Delete
public class DeleteBST {
  public TreeNode delete(TreeNode root, int key) {
    if (root == null) {
      return null;
    }
    if (key == root.key) {
      if (root.left == null) {
        return root.right;
      } else if (root.right == null) {
        return root.left;
      } else if (root.right.left == null) {
        root.right.left = root.left;
        return root.right;
      } else {
        TreeNode newRoot = deleteSmallest(root.right);
        newRoot.left = root.left;
        newRoot.right = root.right;
        return newRoot;
      }
    }
    if (key < root.key) {
      root.left = delete(root.left, key);
    } else if (key > root.key) {
      root.right = delete(root.right, key);
    }
    return root;
  }

  private TreeNode deleteSmallest(TreeNode root) {
    while (root.left.left != null) {
      root = root.left;
    }
    TreeNode smallest = root.left;
    root.left = root.left.right;
    return smallest;
  }
}

Cutting Wood I
public class CuttingWoodI {
  public int minCost(int[] cuts, int length) {
    // Assumptions: cuts is not null, length >= 0, all cuts are valid numbers.
    // First we need to pad the original array at leftmost and
    // rightmost position.
    int[] helper = new int[cuts.length + 2];
    helper[0] = 0;
    for (int i = 0; i < cuts.length; i++) {
      helper[i + 1] = cuts[i];
    }
    helper[helper.length - 1] = length;
    // minCost[i][j]: the min cost of cutting the partition(i,j).
    int[][] minCost = new int[helper.length][helper.length];
    for (int i = 1; i < helper.length; i++) {
      for (int j = i - 1; j >= 0; j--) {
        if (j + 1 == i) {
          minCost[j][i] = 0;
        } else {
          minCost[j][i] = Integer.MAX_VALUE;
          for (int k = j + 1; k <= i - 1; k++) {
            minCost[j][i] = Math.min(minCost[j][i], minCost[j][k] + minCost[k][i]);
          }
          minCost[j][i] += helper[i] - helper[j];
        }
      }
    }
    return minCost[0][helper.length - 1];
  }
}

Merge Stones
public class MergeStones {
  public int minCost(int[] stones) {
    // Assumptions: stones is not null, stones.length >= 1.
    // This problem is actually the same one with Cutting Wood I.
    // Only difference is for each partition(i,j), we need to
    // compute the length.
    int len = stones.length;
    int[][] cost = new int[len][len];
    // subSum[i][j]: the length of partition(i,j).
    int[][] subSum = new int[len][len];
    for (int i = 0; i < len; i++) {
      for (int j = i; j >= 0; j--) {
        if (i == j) {
          cost[j][i] = 0;
          subSum[j][i] = stones[i];
        } else {
          subSum[j][i] = subSum[j][i - 1] + stones[i];
          cost[j][i] = Integer.MAX_VALUE;
          for (int k = j; k < i; k++) {
            cost[j][i] = Math.min(cost[j][i], cost[j][k] + cost[k + 1][i] + subSum[j][i]);
          }
        }
      }
    }
    return cost[0][len - 1];
  }
}

Back To Index

Class 22 - 强化练习 III
Max Path Sum Binary Tree II(path from any node to any node)
public class MaxPathSumBinaryTreeII {
  public int maxPathSum(TreeNode root) {
    // Assumptions: root is not null.
    // max stores the global maximum path sum and will be
    // updated during the recursion.
    int[] max = new int[] { Integer.MIN_VALUE };
    helper(root, max);
    return max[0];
  }

  // return the maximum path sum of the "single" path.
  private int helper(TreeNode root, int[] max) {
    if (root == null) {
      return 0;
    }
    int left = helper(root.left, max);
    int right = helper(root.right, max);
    left = left < 0 ? 0 : left;
    right = right < 0 ? 0 : right;
    max[0] = Math.max(root.key + left + right, max[0]);
    return root.key + Math.max(left, right);
  }
}

Max Path Sum Binary Tree(path from leaf to root)
public class MaxPathSumLeafToRoot {
  // Method 1: Pass down the prefix sum.
  public int maxPathSum(TreeNode root) {
    // Assumptions: root != null
    return maxPathSum(root, 0);
  }

  private int maxPathSum(TreeNode root, int sum) {
    sum += root.key;
    if (root.left == null && root.right == null) {
      return sum;
    } else if (root.left == null) {
      return maxPathSum(root.right, sum);
    } else if (root.right == null) {
      return maxPathSum(root.left, sum);
    }
    return Math.max(maxPathSum(root.left, sum), maxPathSum(root.right, sum));
  }

  // Method 2: Bottom up return the max suffix sum.
  public int maxPathSumII(TreeNode root) {
    // Assumptions: root != null
    if (root.left == null && root.right == null) {
      return root.key;
    }
    if (root.left == null) {
      return maxPathSum(root.right) + root.key;
    }
    if (root.right == null) {
      return maxPathSum(root.left) + root.key;
    }
    return root.key + Math.max(maxPathSum(root.left), maxPathSum(root.right));
  }
}

Binary Tree Path Sum To Target(the two nodes can be the same node and they can only be on the path from root to one of the leaf nodes)
public class BinaryTreePathSumToTarget {
  public boolean exist(TreeNode root, int sum) {
    if (root == null) {
      return false;
    }
    // pass down the prefix of the path.
    List<TreeNode> path = new ArrayList<TreeNode>();
    return helper(root, path, sum);
  }

  private boolean helper(TreeNode root, List<TreeNode> path, int sum) {
    path.add(root);
    // check if can find a subpath ended at root node,
    // the sum of the subpath is target.
    int tmp = 0;
    for (int i = path.size() - 1; i >= 0; i--) {
      tmp += path.get(i).key;
      if (tmp == sum) {
        return true;
      }
    }
    if (root.left != null && helper(root.left, path, sum)) {
      return true;
    }
    if (root.right != null && helper(root.right, path, sum)) {
      return true;
    }
    // don't forget for the cleanup when return to the previous level.
    path.remove(path.size() - 1);
    return false;
  }

  // Method 2: an O(n) solution.
  // Think about the related problem, how do you find if there is
  // a subarray sum to target value?
  // If there is an O(n) solution to the above problem, we can extend
  // it to each of the root->leaf paths of the binary tree.
  public boolean existII(TreeNode root, int sum) {
    if (root == null) {
      return false;
    }
    Set<Integer> prefixSums = new HashSet<>();
    prefixSums.add(0);
    return helperII(root, prefixSums, 0, sum);
  }

  private boolean helperII(TreeNode root, Set<Integer> prefixSums, int prevSum, int sum) {
    prevSum += root.key;
    if (prefixSums.contains(prevSum - sum)) {
      return true;
    }
    boolean needRemove = prefixSums.add(prevSum);
    if (root.left != null && helperII(root.left, prefixSums, prevSum, sum)) {
      return true;
    }
    if (root.right != null && helperII(root.right, prefixSums, prevSum, sum)) {
      return true;
    }
    if (needRemove) {
      prefixSums.remove(prevSum);
    }
    return false;
  }
}

Max Path Sum Binary Tree III(the two nodes can be the same node and they can only be on the path from root to one of the leaf nodes)
public class MaxPathSumBinaryTreeIII {
  public int maxPathSum(TreeNode root) {
    // Assumptions: root is not null.
    int[] max = new int[] { Integer.MIN_VALUE };
    helper(root, max);
    return max[0];
  }

  private int helper(TreeNode root, int[] max) {
    if (root == null) {
      return 0;
    }
    int left = helper(root.left, max);
    int right = helper(root.right, max);
    int sin = Math.max(Math.max(left, right), 0) + root.key;
    max[0] = Math.max(max[0], sin);
    return sin;
  }
}

Reconstruct Binary Tree With Preorder And Inorder
public class ReconstructBTInPre {
  // Method 1: Utilizing the inOrder sequence to determine
  // the size of left/right subtrees.
  public TreeNode reconstruct(int[] in, int[] pre) {
    // Assumptions: pre, in are not null, there is no duplicates
    // in the binary tree, the length of pre an in are guaranteed
    // to be the same.
    Map<Integer, Integer> inIndex = indexMap(in);
    return helper(pre, inIndex, 0, in.length - 1, 0, pre.length - 1);
  }

  private Map<Integer, Integer> indexMap(int[] in) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < in.length; i++) {
      map.put(in[i], i);
    }
    return map;
  }

  private TreeNode helper(int[] pre, Map<Integer, Integer> inIndex, int inLeft, int inRight, int preLeft, int preRight) {
    if (inLeft > inRight) {
      return null;
    }
    TreeNode root = new TreeNode(pre[preLeft]);
    // get the position of the root in inOrder sequence, so that we will know
    // the size of left/right subtrees.
    int inMid = inIndex.get(root.key);
    root.left = helper(pre, inIndex, inLeft, inMid - 1, preLeft + 1, preLeft + inMid - inLeft);
    root.right = helper(pre, inIndex, inMid + 1, inRight, preRight + inMid - inRight + 1, preRight);
    return root;
  }

  // Method 2: Another Linear Solution with traversing and constructing
  // the binary tree using preOrder and inOrder at the same time.
  public TreeNode reconstructII(int[] in, int[] pre) {
    // Assumptions: pre, in are not null, there is no duplicates
    // in the binary tree, the length of pre an in are guaranteed
    // to be the same.
    int[] preIndex = new int[] { 0 };
    int[] inIndex = new int[] { 0 };
    return helperII(pre, in, preIndex, inIndex, Integer.MAX_VALUE);
  }

  private TreeNode helperII(int[] pre, int[] in, int[] preIndex, int[] inIndex, int target) {
    // Traversing and construct the binary tree using preOrder and inOrder,
    // the preOrder is [root][left subtree][right subtree]
    // from the preOrder, we know the root of the binary tree,
    // the inOrder is [left subtree][root][right subtree]
    // when we know the root, we actually know the boundary of
    // the left/right subtree.
    // The "target" is actually the root, and we are using inOrder
    // to identify the boundary of left subtree.
    if (inIndex[0] >= in.length || in[inIndex[0]] == target) {
      return null;
    }
    TreeNode root = new TreeNode(pre[preIndex[0]]);
    // preOrder, advance the index by 1 since we already finish the root.
    preIndex[0]++;
    root.left = helperII(pre, in, preIndex, inIndex, root.key);
    // inOrder, after finish the left subtree, we can advance the index by 1.
    inIndex[0]++;
    root.right = helperII(pre, in, preIndex, inIndex, target);
    return root;
  }
}

Reconstruct Binary Search Tree With Postorder
public class ReconstructBSTPostorder {
  public TreeNode reconstruct(int[] post) {
    // Assumptions: post is not null,
    // there is no duplicate in the binary search tree.
    // Traversing position of the post order,
    // we traverse and construct the binary search tree
    // from the postOrder right to left.
    int[] index = new int[] { post.length - 1 };
    return helper(post, index, Integer.MIN_VALUE);
  }

  private TreeNode helper(int[] postorder, int[] index, int min) {
    // Since it is a binary search tree,
    // the "min" is actually the root,
    // and we are using the root value to determine the boundary
    // of left/right subtree.
    if (index[0] < 0 || postorder[index[0]] <= min) {
      return null;
    }
    TreeNode root = new TreeNode(postorder[index[0]--]);
    root.right = helper(postorder, index, root.key);
    root.left = helper(postorder, index, min);
    return root;
  }
}

Reconstruct Binary Tree With Levelorder And Inorder
public class ReconstructBTInLevel {
  public TreeNode reconstruct(int[] level, int[] in) {
    // Assumptions: level, in are not null,
    // there is no duplicate in the binary tree.
    Map<Integer, Integer> inMap = new HashMap<Integer, Integer>();
    for (int i = 0; i < in.length; i++) {
      inMap.put(in[i], i);
    }
    List<Integer> lList = new ArrayList<Integer>();
    for (int num : level) {
      lList.add(num);
    }
    return helper(lList, inMap);
  }

  private TreeNode helper(List<Integer> level, Map<Integer, Integer> inMap) {
    if (level.isEmpty()) {
      return null;
    }
    TreeNode root = new TreeNode(level.remove(0));
    List<Integer> left = new ArrayList<>();
    List<Integer> right = new ArrayList<>();
    for (int num : level) {
      if (inMap.get(num) < inMap.get(root.key)) {
        left.add(num);
      } else {
        right.add(num);
      }
    }
    root.left = helper(left, inMap);
    root.right = helper(right, inMap);
    return root;
  }
}

Back To Index

Class 24 - 强化练习 IV
Reverse Binary Tree Upside Down
public class BinaryTreeUpsideDown {
  // Method 1: Recursion
  public TreeNode reverse(TreeNode root) {
    if (root == null || root.left == null) {
      return root;
    }
    TreeNode newRoot = reverse(root.left);
    root.left.right = root.right;
    root.left.left = root;
    root.left = null;
    root.right = null;
    return newRoot;
  }

  // Method 2: Iterative
  public TreeNode reverseI(TreeNode root) {
    TreeNode prev = null;
    TreeNode prevRight = null;
    while (root != null) {
      TreeNode next = root.left;
      TreeNode right = root.right;
      root.right = prevRight;
      root.left = prev;
      prevRight = right;
      prev = root;
      root = next;
    }
    return prev;
  }
}

All Valid Permutations Of Parentheses II(L pairs of (), M pairs of [], N pairs of{})
public class ValidParenthesesII {
  private static final char[] PS = new char[] { '(', ')', '[', ']', '{', '}' };

  public List<String> validParentheses(int l, int m, int n) {
    // Assumptions: l, m, n >= 0.
    int[] remain = new int[] { l, l, m, m, n, n };
    int targetLen = 2 * l + 2 * m + 2 * n;
    StringBuilder cur = new StringBuilder();
    Deque<Character> stack = new LinkedList<Character>();
    List<String> result = new ArrayList<String>();
    helper(cur, stack, remain, targetLen, result);
    return result;
  }

  private void helper(StringBuilder cur, Deque<Character> stack, int[] remain, int targetLen, List<String> result) {
    if (cur.length() == targetLen) {
      result.add(cur.toString());
      return;
    }
    for (int i = 0; i < remain.length; i++) {
      if (i % 2 == 0) {
        if (remain[i] > 0) {
          cur.append(PS[i]);
          stack.offerFirst(PS[i]);
          remain[i]--;
          helper(cur, stack, remain, targetLen, result);
          cur.deleteCharAt(cur.length() - 1);
          stack.pollFirst();
          remain[i]++;
        }
      } else {
        if (!stack.isEmpty() && stack.peekFirst() == PS[i - 1]) {
          cur.append(PS[i]);
          stack.pollFirst();
          remain[i]--;
          helper(cur, stack, remain, targetLen, result);
          cur.deleteCharAt(cur.length() - 1);
          stack.offerFirst(PS[i - 1]);
          remain[i]++;
        }
      }
    }
  }
}

All Subsequences Of Sorted String(All Subsets II)
public class SubSetsII {
  // Method 1: DFS I.
  public List<String> subSets(String set) {
    List<String> result = new ArrayList<String>();
    if (set == null) {
      return result;
    }
    char[] arraySet = set.toCharArray();
    // Make sure the multi-set is sorted so that we can dedup.
    Arrays.sort(arraySet);
    StringBuilder sb = new StringBuilder();
    helper(arraySet, sb, 0, result);
    return result;
  }

  // index: at current level, determine if the element at "index" should be
  // included in the subset or not.
  private void helper(char[] set, StringBuilder sb, int index, List<String> result) {
    if (index == set.length) {
      result.add(sb.toString());
      return;
    }
    helper(set, sb.append(set[index]), index + 1, result);
    sb.deleteCharAt(sb.length() - 1);
    // skip all the consecutive and duplicate elements.
    while (index < set.length - 1 && set[index] == set[index + 1]) {
      index++;
    }
    helper(set, sb, index + 1, result);
  }

  // Method 2: DFS II.
  public List<String> subSetsII(String set) {
    List<String> result = new ArrayList<String>();
    if (set == null) {
      return result;
    }
    char[] arraySet = set.toCharArray();
    // Make sure the multi-set is sorted so that we can dedup.
    Arrays.sort(arraySet);
    StringBuilder sb = new StringBuilder();
    helperII(arraySet, sb, 0, result);
    return result;
  }

  // index: We pick the element by ascending order, "index" is the smallest
  // index we can pick for the subset.
  private void helperII(char[] set, StringBuilder sb, int index, List<String> result) {
    result.add(sb.toString());
    // For the consecutive duplicate elements, we only pick the first one.
    for (int i = index; i < set.length; i++) {
      if (i == index || set[i] != set[i - 1]) {
        sb.append(set[i]);
        helperII(set, sb, i + 1, result);
        sb.deleteCharAt(sb.length() - 1);
      }
    }
  }
}

2 Sum
public class TwoSum {
  // Method 1: sort the array first, then use two pointers.
  public boolean existSum(int[] array, int target) {
    // Assumptions: array is not null, and has size >= 2.
    Arrays.sort(array);
    int left = 0;
    int right = array.length - 1;
    while (left < right) {
      int sum = array[left] + array[right];
      if (sum == target) {
        return true;
      } else if (sum < target) {
        left++;
      } else {
        right--;
      }
    }
    return false;
  }

  // Method 2: use HashSet to record the previous traversed values.
  public boolean existSumII(int[] array, int target) {
    // Assumptions: array is not null, and has size >= 2.
    Set<Integer> set = new HashSet<Integer>();
    for (int num : array) {
      if (set.contains(target - num)) {
        return true;
      }
      set.add(num);
    }
    return false;
  }
}

2 Sum All Pair I
public class TwoSumAllPairsI {
  public List<List<Integer>> allPairs(int[] array, int target) {
    // Assumptions: array is not null, array.length >= 2
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    // key: number, value: list of all possible indices.
    Map<Integer, List<Integer>> map = new HashMap<Integer, List<Integer>>();
    for (int i = 0; i < array.length; i++) {
      List<Integer> indices = map.get(target - array[i]);
      // if target - array[i] is in the map,
      // we can get all the pairs(j,i), with i as the larger index.
      if (indices != null) {
        for (int j : indices) {
          result.add(Arrays.asList(j, i));
        }
      }
      // add current index i to all the possible indices for value of array[i]
      if (!map.containsKey(array[i])) {
        map.put(array[i], new ArrayList<Integer>());
      }
      map.get(array[i]).add(i);
    }
    return result;
  }
}

2 Sum All Pair II
public class TwoSumAllPairsII {
  // Method 1: sort the array first and use two pointers.
  public List<List<Integer>> allPairs(int[] array, int target) {
    // Assumptions: array is not null, array.length >= 2.
    Arrays.sort(array);
    List<List<Integer>> result = new ArrayList<>();
    int left = 0;
    int right = array.length - 1;
    while (left < right) {
      // ignore all the consecutive duplicate values when we want
      // to determine the smaller element of the pair.
      if (left > 0 && array[left] == array[left - 1]) {
        left++;
        continue;
      }
      int cur = array[left] + array[right];
      if (cur == target) {
        result.add(Arrays.asList(array[left], array[right]));
        left++;
        right--;
      } else if (cur < target) {
        left++;
      } else {
        right--;
      }
    }
    return result;
  }

  // Method 2: use HashSet.
  public List<List<Integer>> allPairsII(int[] array, int target) {
    // Assumptions: array is not null, array.length >= 2.
    List<List<Integer>> result = new ArrayList<>();
    // Record the number of existence of the values.
    Map<Integer, Integer> map = new HashMap<>();
    for (int num : array) {
      // Two cases when we need to make the pair a solution:
      // 1. if 2 * x == target, and we need to make sure there is no duplicates.
      // 2. if x + y == target, and this is the first time both x and y
      // are present, so we can make sure there is no duplicates.
      Integer count = map.get(num);
      if (num * 2 == target && count != null && count == 1) {
        result.add(Arrays.asList(num, num));
      } else if (map.containsKey(target - num) && count == null) {
        result.add(Arrays.asList(target - num, num));
      }
      if (count == null) {
        map.put(num, 1);
      } else {
        map.put(num, count + 1);
      }
    }
    return result;
  }
}

3 Sum
public class ThreeSum {
  public List<List<Integer>> allTriples(int[] array, int target) {
    // Assumptions: array is not null, array.length >= 3.
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    Arrays.sort(array);
    for (int i = 0; i < array.length - 2; i++) {
      // Our goal is to find i < j < k, such that
      // array[i] + array[j] + array[k] == target,
      // To make sure there is no duplicate tuple,
      // We ignore all the duplicate possible i.
      // e.g, if we have 2, 2, 2, only the first 2 will be selected as i.
      if (i > 0 && array[i] == array[i - 1]) {
        continue;
      }
      int left = i + 1;
      int right = array.length - 1;
      while (left < right) {
        int tmp = array[left] + array[right];
        if (tmp + array[i] == target) {
          result.add(Arrays.asList(array[i], array[left], array[right]));
          left++;
          // ignore all possible duplicate j as well.
          while (left < right && array[left] == array[left - 1]) {
            left++;
          }
        } else if (tmp + array[i] < target) {
          left++;
        } else {
          right--;
        }
      }
    }
    return result;
  }
}

4 Sum
public class FourSum {
  // Method 1: sort the array first, O(n^3).
  public boolean exist(int[] array, int target) {
    // Assumptions: array is not null, array.length >= 4.
    Arrays.sort(array);
    for (int i = 0; i < array.length - 3; i++) {
      for (int j = i + 1; j < array.length - 2; j++) {
        int left = j + 1;
        int right = array.length - 1;
        int curTarget = target - array[i] - array[j];
        while (left < right) {
          int sum = array[left] + array[right];
          if (sum == curTarget) {
            return true;
          } else if (sum < curTarget) {
            left++;
          } else {
            right--;
          }
        }
      }
    }
    return false;
  }

  // each element record a pair of numbers in the array.
  // left: the smaller index of the pair of numbers.
  // right: the larger index of the pair of numbers.
  // sum: the sum of the pair of numbers.
  static class Element implements Comparable<Element> {
    int left;
    int right;
    int sum;

    Element(int left, int right, int sum) {
      this.left = left;
      this.right = right;
      this.sum = sum;
    }

    // we define the order of the element:
    // first by the sum value, then by the right index, then by the left index.
    @Override
    public int compareTo(Element another) {
      if (this.sum != another.sum) {
        return this.sum < another.sum ? -1 : 1;
      } else if (this.right != another.right) {
        return this.right < another.right ? -1 : 1;
      } else if (this.left != another.left) {
        return this.left < another.left ? -1 : 1;
      }
      return 0;
    }
  }

  // Method 2: O(n^2 * logn), get all pairs of numbers and apply 2 sum.
  public boolean existII(int[] array, int target) {
    // Assumptions: array is not null, array.length >= 4.
    // we need to sort the array first, and find i,j,k,l such that
    // i<j<k<j, and the sum is target.
    // we split the tuples into two pair elements: (i,j) and (k,l),
    // so that array[i] + array[j] <= array[k] + array[l].
    Arrays.sort(array);
    Element[] pairSum = getPairSum(array);
    Arrays.sort(pairSum);
    int left = 0;
    int right = pairSum.length - 1;
    // pairSum are sorted by sum, then right index, then left index.
    while (left < right) {
      // only return true if two pair sums' sum is target and the larger pair
      // sum's left index > smaller pair sum's large index.
      if (pairSum[left].sum + pairSum[right].sum == target && pairSum[left].right < pairSum[right].left) {
        return true;
      } else if (pairSum[left].sum + pairSum[right].sum < target) {
        left++;
      } else {
        // when two pair sums' sum > target, right--
        // when two pair sums' sum == target but larger pair sum's left index
        // <= smaller pair sum's right index, we need to do right--,
        // because the only thing we can guarantee is that
        // right now the smaller pair sum's right index is the smallest one
        // among all pairSums with the same sum, and it is possible we can find
        // another pair with smaller right index.
        right--;
      }
    }
    return false;
  }

  private Element[] getPairSum(int[] array) {
    Element[] pairSum = new Element[array.length * (array.length - 1) / 2];
    int curIndex = 0;
    for (int i = 1; i < array.length; i++) {
      for (int j = 0; j < i; j++) {
        pairSum[curIndex++] = new Element(j, i, array[i] + array[j]);
      }
    }
    return pairSum;
  }

  // each pair is representing a pair of numbers in the array by their index.
  static class Pair {
    int left;
    int right;

    Pair(int left, int right) {
      this.left = left;
      this.right = right;
    }
  }

  // Method 3: HashMap O(n ^ 2).
  public boolean existIII(int[] array, int target) {
    // Assumptions: array is not null, array.length >= 4.
    Map<Integer, Pair> map = new HashMap<>();
    // the order of traversing i, j is not arbitrary, we should guarantee
    // we can always look at the pair with the smallest right index.
    for (int i = 1; i < array.length; i++) {
      for (int j = 0; j < i; j++) {
        int pairSum = array[j] + array[i];
        // we need to guarantee there exists another pair with right index
        // smaller than the current pair's left index.
        if(map.containsKey(target - pairSum) && map.get(target - pairSum).right < j){
          return true;
        }
        // we only need to store the pair with smallest right index.
        if (!map.containsKey(pairSum)) {
          map.put(pairSum, new Pair(j, i));
        }
      }
    }
    return false;
  }
}

Common Elements In Three Sorted Arrays
public class CommonElementsII {
  public List<Integer> common(int[] a, int[] b, int[] c) {
    // Assumptions: a, b, c are not null.
    List<Integer> common = new ArrayList<Integer>();
    int ai = 0;
    int bi = 0;
    int ci = 0;
    while (ai < a.length && bi < b.length && ci < c.length) {
      if (a[ai] == b[bi] && b[bi] == c[ci]) {
        common.add(a[ai]);
        ai++;
        bi++;
        ci++;
      } else if (a[ai] <= b[bi] && a[ai] <= c[ci]) {
        ai++;
      } else if (b[bi] <= a[ai] && b[bi] <= c[ci]) {
        bi++;
      } else {
        ci++;
      }
    }
    return common;
  }
}

Back To Index

Class 25 - 加强练习 V
Largest Product of Length
// Given a dictionary containing many words,
// find the largest product of two words' lengths,
// such that the two words do not share any common characters.
public class Q191_LargestLengthProduct {
  public int largestProduct(String[] dict) {
    // Assumptions: dict is not null and has length >= 2,
    // there is no null String in the dict.
    // The words in the dict only use characters 'a' - 'z'.
    // Get the bit mask for each of the word in the dict,
    // the bit mask is represented by the lowest 26 bits of an integer.
    // each of the bit represents one of the characters in 'a' - 'z'.
    HashMap<String, Integer> bitMasks = getBitMasks(dict);
    // sort the dict by length of the words in descending order.
    Arrays.sort(dict, new Comparator<String>() {
      @Override
      public int compare(String s0, String s1) {
        if (s0.length() == s1.length()) {
          return 0;
        }
        return s0.length() < s1.length() ? 1 : -1;
      }
    });
    int largest = 0;
    // note the order of constructing all the pairs,
    // we make our best to try largest product.
    for (int i = 1; i < dict.length; i++) {
      for (int j = 0; j < i; j++) {
        // early break if the product is already smaller than
        // the current largest one.
        int prod = dict[i].length() * dict[j].length();
        if (prod <= largest) {
          break;
        }
        int iMask = bitMasks.get(dict[i]);
        int jMask = bitMasks.get(dict[j]);
        // if two words do not share any common characters,
        // the bit masks "and" result should be 0 since
        // there is not any position such that in the two bit masks
        // they are all 1.
        if ((iMask & jMask) == 0) {
          largest = prod;
        }
      }
    }
    return largest;
  }

  // Get the bit mask for each of the words.
  private HashMap<String, Integer> getBitMasks(String[] dict) {
    HashMap<String, Integer> map = new HashMap<String, Integer>();
    for (String str : dict) {
      int bitMask = 0;
      for (int i = 0; i < str.length(); i++) {
        // the 26 characters 'a'-'z' are mapped to 0 - 25th bit.
        // to determine which bit it is for a character x,
        // use (x - 'a') since their values are in a consecutive range.
        // if character x exists in the word, we set the bit at
        // corresponding index to 1.
        bitMask |= 1 << (str.charAt(i) - 'a');
      }
      map.put(str, bitMask);
    }
    return map;
  }
}

Kth Smallest With Only 3,5,7 As Factors
public class KthSmallestThreeFiveSeven {
  // Method 1: BFS
  public long kth(int K) {
    // Assumptions: K >= 1.
    PriorityQueue<Long> minHeap = new PriorityQueue<>(K);
    Set<Long> visited = new HashSet<>();
    // we use the actual product value to represent the states
    // <x,y,z>, the value is 3^x * 5^y * 7^z, and the initial
    // state is <1,1,1>.
    minHeap.offer(3 * 5 * 7L);
    visited.add(3 * 5 * 7L);
    while (K > 1) {
      long current = minHeap.poll();
      // for the state <x+1,y,z>, the actual value is *3.
      if (visited.add(3 * current)) {
        minHeap.offer(3 * current);
      }
      // for the state <x,y+1,z>, the actual value is *5.
      if (visited.add(5 * current)) {
        minHeap.offer(5 * current);
      }
      // for the state <x,y,z+1>, the actual value is *7.
      if (visited.add(7 * current)) {
        minHeap.offer(7 * current);
      }
      K--;
    }
    return minHeap.peek();
  }

  // Method 2: Linear solution using 3 deques.
  public long kthII(int K) {
    // Assumptions: K >= 1.
    long seed = 3 * 5 * 7L;
    // We use three deques to maintain all the possible values.
    // The rule is:
    // deque3 only maintains the value of seed * 3^x.
    // deque5 only maintains the value of seed * 3^x * 5^y.
    // deque7 only maintains the value of seed * 3^x * 5^y * 7^z.
    Deque<Long> three = new LinkedList<>();
    Deque<Long> five = new LinkedList<>();
    Deque<Long> seven = new LinkedList<>();
    three.add(seed * 3);
    five.add(seed * 5);
    seven.add(seed * 7);
    long result = seed;
    while (K > 1) {
      // each round, pick the smallest one from the head of the three deques.
      // when pushing back the value into the deques, following the rule:
      // 
      // if the smallest number x is from deque3:
      // we need to push x*3 to deque3, x*5 to deque5 and x*7 to deque7,
      // to maintain the property of the three deques.
      //
      // if the smallest number x is from deque5:
      // we only need to push x*5 to deque5 and x*7 to deque7,
      // we do not need to push x*3 again,
      // because x*3 has to be already generated before,
      // x= 3^a*5^b, x*3 = 3^(a+1)*5^b = 3^(a+1)*5^(b-1)*5,
      // and 3^(a+1)*5^(b-1) < x, it means x*3 has to be already
      // generated by 3^(a+1)*5(b-1), and it already in deque5.
      //
      // similarly, if the smallest number x is from deque7:
      // we only need to push x*7 to deque7.
      if (three.peekFirst() < five.peekFirst() && three.peekFirst() < seven.peekFirst()) {
        result = three.pollFirst();
        three.offerLast(result * 3);
        five.offerLast(result * 5);
        seven.offerLast(result * 7);
      } else if (five.peekFirst() < three.peekFirst() && five.peekFirst() < seven.peekFirst()) {
        result = five.pollFirst();
        five.offerLast(result * 5);
        seven.offerLast(result * 7);
      } else {
        result = seven.pollFirst();
        seven.offerLast(result * 7);
      }
      K--;
    }
    return result;
  }
}

Kth Closest Point To <0,0,0>
public class KthClosestPoint {
  public List<Integer> closest(final int[] a, final int[] b, final int[] c, int k) {
    // Assumptions: a, b, c are not null, length >= 1,
    // k >= 1 && k <= a.length * b.length * c.length.
    // we will need a min heap, with comparator to compare the distance.
    // Note that we are using the index in a,b,c as values in the List<Integer>.
    PriorityQueue<List<Integer>> minHeap = new PriorityQueue<>(2 * k, new Comparator<List<Integer>>() {
      @Override
      public int compare(List<Integer> o1, List<Integer> o2) {
        long d1 = distance(o1, a, b, c);
        long d2 = distance(o2, a, b, c);
        if (d1 == d2) {
          return 0;
        }
        return d1 < d2 ? -1 : 1;
      }
    });
    // Note that List's equals() method has been already overridden,
    // and it is comparing the actual elements in the List.
    Set<List<Integer>> visited = new HashSet<>();
    // The initial state is <0,0,0>, meaning picking the smallest elements
    // from the three arrays.
    List<Integer> cur = Arrays.asList(0, 0, 0);
    visited.add(cur);
    minHeap.offer(cur);
    while (k > 0) {
      cur = minHeap.poll();
      List<Integer> n = Arrays.asList(cur.get(0) + 1, cur.get(1), cur.get(2));
      if (n.get(0) < a.length && visited.add(n)) {
        minHeap.offer(n);
      }
      n = Arrays.asList(cur.get(0), cur.get(1) + 1, cur.get(2));
      if (n.get(1) < b.length && visited.add(n)) {
        minHeap.offer(n);
      }
      n = Arrays.asList(cur.get(0), cur.get(1), cur.get(2) + 1);
      if (n.get(2) < c.length && visited.add(n)) {
        minHeap.offer(n);
      }
      k--;
    }
    // at last, we replace the index with actual values in a, b, c.
    cur.set(0, a[cur.get(0)]);
    cur.set(1, b[cur.get(1)]);
    cur.set(2, c[cur.get(2)]);
    return cur;
  }

  private long distance(List<Integer> point, int[] a, int[] b, int[] c) {
    long dis = 0;
    dis += a[point.get(0)] * a[point.get(0)];
    dis += b[point.get(1)] * b[point.get(1)];
    dis += c[point.get(2)] * c[point.get(2)];
    return dis;
  }
}

Place To Put Chair I
/**
 * Given a gym with k equipments, and some obstacles. We bought a chair and
 * wanted to put this chair into the gym such that the sum of the shortest path
 * cost from the chair to the k equipments is minimal.
 * 
 * Assumption:
 * 1). The cost from one cell to any of its neighbors(up/down/left/right) is 1.
 * 2). 'E' denotes equipment, 'O' denotes obstacle, 'C' denotes empty cell.
 * 3). The chair can not be put on equipment or obstacle.
 * 4). Each 'C' cell is reachable from all 'E' cells.
 */
public class PlaceToPutChairI {
  private static final char EQUIP = 'E';
  private static final char OB = 'O';

  public List<Integer> putChair(char[][] gym) {
    // Assumptions: gym is not null, has size M * N,
    // where M >= 1 and N >= 1,
    // return null if you can not put the chair anywhere.
    // there is at least one equipment in the gym.
    int M = gym.length;
    int N = gym[0].length;
    // use a matrix to record the sum of shortest path cost
    // from each cell to all the 'E' cells.
    int[][] cost = new int[M][N];
    for (int i = 0; i < M; i++) {
      for (int j = 0; j < N; j++) {
        if (EQUIP == gym[i][j]) {
          // use BFS to calculate the shortest path cost from
          // each of the equipments to all the other reachable cells
          // and add the cost to each corresponding cell.
          // Note the return boolean value represents if there exists
          // another 'E' cell not reachable from the current one,
          // if so, there won't exits a cell to place the chair.
          if (!addCost(cost, gym, i, j)) {
            return null;
          }
        }
      }
    }
    // find the cell with smallest sum of shorted path costs
    // to all the 'E' cells.
    List<Integer> result = null;
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < N; j++) {
        if (EQUIP != gym[i][j] && OB != gym[i][j]) {
          if (result == null) {
            result = Arrays.asList(i, j);
          } else if (cost[i][j] < cost[result.get(0)][result.get(1)]) {
            result.set(0, i);
            result.set(1, j);
          }
        }
      }
    }
    return result;
  }

  private boolean addCost(int[][] cost, char[][] gym, int i, int j) {
    // use a boolean matrix to make sure each cell will be visited
    // no more than once.
    boolean[][] visited = new boolean[gym.length][gym[0].length];
    // Bread-First-Search, record the current path cost.
    int pathCost = 1;
    Queue<Pair> queue = new LinkedList<>();
    visited[i][j] = true;
    queue.offer(new Pair(i, j));
    while (!queue.isEmpty()) {
      int size = queue.size();
      for (int l = 0; l < size; l++) {
        Pair cur = queue.poll();
        List<Pair> neis = getNeis(cur, gym);
        for (Pair nei : neis) {
          if (!visited[nei.i][nei.j]) {
            visited[nei.i][nei.j] = true;
            cost[nei.i][nei.j] += pathCost;
            queue.offer(nei);
          }
        }
      }
      // advance the pathCost by 1 for each level.
      pathCost++;
    }

    // if there exists another 'E' cell not reachable from
    // the path start 'E' cell, we return false.
    for (int l = 0; l < gym.length; l++) {
      for (int m = 0; m < gym[0].length; m++) {
        if (!visited[l][m] && EQUIP == gym[l][m]) {
          return false;
        }
      }
    }
    return true;
  }

  private List<Pair> getNeis(Pair cur, char[][] gym) {
    int x = cur.i;
    int y = cur.j;
    int M = gym.length;
    int N = gym[0].length;
    List<Pair> neis = new ArrayList<>();
    if (x + 1 < M && OB != gym[x + 1][y]) {
      neis.add(new Pair(x + 1, y));
    }
    if (y + 1 < N && OB != gym[x][y + 1]) {
      neis.add(new Pair(x, y + 1));
    }
    if (x - 1 >= 0 && OB != gym[x - 1][y]) {
      neis.add(new Pair(x - 1, y));
    }
    if (y - 1 >= 0 && OB != gym[x][y - 1]) {
      neis.add(new Pair(x, y - 1));
    }
    return neis;
  }

  static class Pair {
    int i;
    int j;

    Pair(int i, int j) {
      this.i = i;
      this.j = j;
    }
  }
}

Largest Rectangle In Histogram
public class LargestRectangleHistogram {
  public int largest(int[] array) {
    // Assumptions: array is not null, array.length >= 1,
    // all the values in the array are non-negative.
    int result = 0;
    // Note that the stack contains the "index",
    // not the "value" of the array.
    Deque<Integer> stack = new LinkedList<Integer>();
    for (int i = 0; i <= array.length; i++) {
      // we need a way of popping out all the elements in the stack
      // at last, so that we explicitly add a bar of height 0.
      int cur = i == array.length ? 0 : array[i];
      while (!stack.isEmpty() && array[stack.peekFirst()] >= cur) {
        int height = array[stack.pollFirst()];
        // determine the left boundary of the largest rectangle
        // with height array[i].
        int left = stack.isEmpty() ? 0 : stack.peekFirst() + 1;
        // determine the right boundary of the largest rectangle
        // with height of the popped element.
        result = Math.max(result, height * (i - left));
      }
      stack.offerFirst(i);
    }
    return result;
  }
}

Max Water Trapped I
public class MaxWaterTrappedI {
  public int maxTrapped(int[] array) {
    // Assumptions: array is not null.
    if (array.length == 0) {
      return 0;
    }
    int left = 0;
    int right = array.length - 1;
    int result = 0;
    int lmax = array[left];
    int rmax = array[right];
    while (left < right) {
      if (array[left] <= array[right]) {
        result += Math.max(0, lmax - array[left]);
        lmax = Math.max(lmax, array[left]);
        left++;
      } else {
        result += Math.max(0, rmax - array[right]);
        rmax = Math.max(rmax, array[right]);
        right--;
      }
    }
    return result;
  }
}

Max Water Trapped II
public class MaxWaterTrappedII {
  public int maxTrapped(int[][] matrix) {
    // Assumptions: matrix is not null, has size of M * N,
    // M > 0 & N > 0, all the values are non-negative integers.
    int rows = matrix.length;
    int cols = matrix[0].length;
    if (rows < 3 || cols < 3) {
      return 0;
    }
    // Best-First-Search, minHeap maintains all the border cells
    // of the "closed area" and we always find the one with lowest
    // height to see if any of its neighbors can trap any water.
    PriorityQueue<Pair> minHeap = new PriorityQueue<Pair>();
    boolean[][] visited = new boolean[rows][cols];
    // put all the border cells of the matrix at the beginning.
    processBorder(matrix, visited, minHeap, rows, cols);
    int result = 0;
    while (!minHeap.isEmpty()) {
      Pair cur = minHeap.poll();
      // get all possible neighbor cells.
      List<Pair> neighbors = allNeighbors(cur, matrix, visited);
      for (Pair nei : neighbors) {
        // if any neighbor has been visited before, we just ignore.
        if (visited[nei.x][nei.y]) {
          continue;
        }
        // adjust the neighbor cell's height to the current water level
        // if necessary, mark the neighbor cell as visited, and put the
        // neighbor cell into the min heap.
        visited[nei.x][nei.y] = true;
        // how much water can be trapped at the neighbor cell.
        // the maximum water level currently is controlled by the cur cell.
        result += Math.max(cur.height - nei.height, 0);
        nei.height = Math.max(cur.height, nei.height);
        minHeap.offer(nei);
      }
    }
    return result;
  }

  // put all the border cells into the min heap at the very beginning,
  // these are the start points of the whole BFS process.
  private void processBorder(int[][] matrix, boolean[][] visited, PriorityQueue<Pair> minHeap,
      int rows, int cols) {
    for (int j = 0; j < cols; j++) {
      minHeap.offer(new Pair(0, j, matrix[0][j]));
      minHeap.offer(new Pair(rows - 1, j, matrix[rows - 1][j]));
      visited[0][j] = true;
      visited[rows - 1][j] = true;
    }

    for (int i = 1; i < rows - 1; i++) {
      minHeap.offer(new Pair(i, 0, matrix[i][0]));
      minHeap.offer(new Pair(i, cols - 1, matrix[i][cols - 1]));
      visited[i][0] = true;
      visited[i][cols - 1] = true;
    }
  }

  private List<Pair> allNeighbors(Pair cur, int[][] matrix, boolean[][] visited) {
    List<Pair> neis = new ArrayList<>();
    if (cur.x + 1 < matrix.length) {
      neis.add(new Pair(cur.x + 1, cur.y, matrix[cur.x + 1][cur.y]));
    }
    if (cur.x - 1 >= 0) {
      neis.add(new Pair(cur.x - 1, cur.y, matrix[cur.x - 1][cur.y]));
    }
    if (cur.y + 1 < matrix[0].length) {
      neis.add(new Pair(cur.x, cur.y + 1, matrix[cur.x][cur.y + 1]));
    }
    if (cur.y - 1 >= 0) {
      neis.add(new Pair(cur.x, cur.y - 1, matrix[cur.x][cur.y - 1]));
    }
    return neis;
  }

  static class Pair implements Comparable<Pair> {
    int x; // row index.
    int y; // column index.
    int height; // height of the cell in the original matrix.

    Pair(int x, int y, int height) {
      this.x = x;
      this.y = y;
      this.height = height;
    }

    @Override
    public int compareTo(Pair another) {
      if (this.height == another.height) {
        return 0;
      }
      return this.height < another.height ? -1 : 1;
    }
  }
}

Back To Index

Class 27 - 加强练习 VI
Kth Smallest In Two Sorted Arrays
public class KthSmallestTwoSortedArray {
  public int kth(int[] a, int[] b, int k) {
    // Assumptions: a, b is not null, at least one of them
    // is not empty, k <= a.length + b.length, k >=1.
    return kth(a, 0, b, 0, k);
  }

  // in the subarray of a starting from index aleft, and
  // subarray of b starting from index bleft, find the kth smallest
  // element among these two subarrays.
  private int kth(int[] a, int aleft, int[] b, int bleft, int k) {
    // three base cases:
    // 1. we already eliminate all the elements in a.
    // 2. we already eliminate all the elements in b.
    // 3. when k is reduced to 1, don't miss this base case.
    // The reason why we have this as base case is in the following
    // logic we need k >= 2 to make it work.
    if (aleft >= a.length) {
      return b[bleft + k - 1];
    }
    if (bleft >= b.length) {
      return a[aleft + k - 1];
    }
    if (k == 1) {
      return Math.min(a[aleft], b[bleft]);
    }
    // we compare the k/2 th element in a's subarray.
    // and the k/2 th element in b's subarray.
    // to determine which k/2 partition can be surely included
    // in the smallest k elements.
    int amid = aleft + k / 2 - 1;
    int bmid = bleft + k / 2 - 1;
    int aval = amid >= a.length ? Integer.MAX_VALUE : a[amid];
    int bval = bmid >= b.length ? Integer.MAX_VALUE : b[bmid];
    if (aval <= bval) {
      return kth(a, amid + 1, b, bleft, k - k / 2);
    } else {
      return kth(a, aleft, b, bmid + 1, k - k / 2);
    }
  }
}

Maximum Values Of Size K Sliding Windows
public class MaxValuesSlidingWindows {
  public List<Integer> maxWindows(int[] array, int k) {
    // Assumptions: array is not null or not empty,
    // k >= 1 and k <= a.length.
    List<Integer> max = new ArrayList<Integer>();
    // use a descending deque to solve this problem,
    // we store the index instead of the actual value in the deque,
    // and we make sure:
    // 1. the deque only contains index in the current sliding window.
    // 2. for any index, the previous index with smaller value is
    // discarded from the deque.
    Deque<Integer> deque = new LinkedList<Integer>();
    for (int i = 0; i < array.length; i++) {
      // discard any index with smaller value than index i.
      while (!deque.isEmpty() && array[deque.peekLast()] <= array[i]) {
        deque.pollLast();
      }
      // it is possible the head element is out of the current
      // sliding window so we might need to discard it as well.
      if (!deque.isEmpty() && deque.peekFirst() <= i - k) {
        deque.pollFirst();
      }
      deque.offerLast(i);
      if (i >= k - 1) {
        max.add(array[deque.peekFirst()]);
      }
    }
    return max;
  }
}

Implement LRU Cache
public class LRUCache<K, V> {
  // each node contains the key, value pair,
  // and it is also a double linked list node.
  static class Node<K, V> {
    Node<K, V> next;
    Node<K, V> prev;
    K key;
    V value;

    Node(K key, V value) {
      this.key = key;
      this.value = value;
    }

    void update(K key, V value) {
      this.key = key;
      this.value = value;
    }
  }

  // make it final for the pre-defined size limit of the cache.
  private final int limit;
  // record all the time the head and tail of the double linked list.
  private Node<K, V> head;
  private Node<K, V> tail;
  // maintains the relationship of key and its corresponding node
  // in the double linked list.
  private Map<K, Node<K, V>> map;

  public LRUCache(int limit) {
    this.limit = limit;
    this.map = new HashMap<K, Node<K, V>>();
  }

  public void set(K key, V value) {
    Node<K, V> node = null;
    // 1. if the key already in the cache, we need to update its value
    // and move it to head(most recent position).
    if (map.containsKey(key)) {
      node = map.get(key);
      node.value = value;
      remove(node);
    } else if (map.size() < limit) {
      // 2. if the key is not in the cache and we still have space,
      // we can add append a new node to head.
      node = new Node<K, V>(key, value);
    } else {
      // 3. if the key is not in the cache and we don't have space,
      // we need to evict the tail and reuse the node let it maintain
      // the new key,value and put it to head.
      node = tail;
      remove(node);
      node.update(key, value);
    }
    append(node);
  }

  public V get(K key) {
    Node<K, V> node = map.get(key);
    if (node == null) {
      return null;
    }
    // even it is a read operation, it is still a write operation to
    // the double linked list, and we need to move the node to head.
    remove(node);
    append(node);
    return node.value;
  }

  private Node<K, V> remove(Node<K, V> node) {
    map.remove(node.key);
    if (node.prev != null) {
      node.prev.next = node.next;
    }
    if (node.next != null) {
      node.next.prev = node.prev;
    }
    if (node == head) {
      head = head.next;
    }
    if (node == tail) {
      tail = tail.prev;
    }
    node.next = node.prev = null;
    return node;
  }

  private Node<K, V> append(Node<K, V> node) {
    map.put(node.key, node);
    if (head == null) {
      head = tail = node;
    } else {
      node.next = head;
      head.prev = node;
      head = node;
    }
    return node;
  }
}

First Non-Repeating Character In Stream
public class FirstNonRepeating {
  // each node is a double linked list node
  // and it contains one distinct character.
  static class Node {
    Node prev;
    Node next;
    Character ch;

    Node(Character ch) {
      this.ch = ch;
    }
  }

  // record the head and tail of the list all the time.
  // only the characters appearing just once will be
  // in the double linked list.
  private Node head;
  private Node tail;
  // for any character, it could be in three state:
  // 1. not existed yet, it will not be singled Map
  // or repeated Set.
  // 2. only exists once, it will be in singled Map
  // and there will be a corresponding node in the list.
  // 3. exists more than once, it will be in the repeated Set.
  // and it will be removed from the list.
  private HashMap<Character, Node> singled;
  private HashSet<Character> repeated;

  public FirstNonRepeating() {
    // an example of using sentinel node to eliminate some corner cases.
    tail = new Node(null);
    tail.next = tail.prev = tail;
    head = tail;
    singled = new HashMap<Character, Node>();
    repeated = new HashSet<Character>();
  }

  public void read(char ch) {
    // if the character already exists more than once,
    // we just ignore.
    if (repeated.contains(ch)) {
      return;
    }
    Node node = singled.get(ch);
    if (node == null) {
      // if the character appears for the first time,
      // it should be added to the list and added to
      // the nonRepeated.
      node = new Node(ch);
      append(node);
    } else {
      // if the character is already in the nonRepeated
      // Map, we should remove it from the Map and list,
      // and put it into the repeated Set.
      remove(node);
    }
  }

  private void append(Node node) {
    singled.put(node.ch, node);
    tail.next = node;
    node.prev = tail;
    node.next = head;
    tail = tail.next;
  }

  private void remove(Node node) {
    // use sentinel node so that some of the
    // corner cases will be eliminated.
    node.prev.next = node.next;
    node.next.prev = node.prev;
    if (node == tail) {
      tail = node.prev;
    }
    node.prev = node.next = null;
    repeated.add(node.ch);
    singled.remove(node.ch);
  }

  public Character firstNonRepeating() {
    // when head == tail, it means there is only
    // the sentinel node in the list.
    if (head == tail) {
      return null;
    }
    return head.next.ch;
  }
}

Majority Number I
public class MajorityNumberI {
  public int majority(int[] array) {
    // Assumptions: array is not null and is not empty.
    // majority number guarantees to exist.
    int candidate = array[0];
    int count = 1;
    for (int i = 1; i < array.length; i++) {
      if (count == 0) {
        count++;
        candidate = array[i];
      } else if (candidate == array[i]) {
        count++;
      } else {
        count--;
      }
    }
    return candidate;
  }
}

Interleave Strings
public class InterleaveStrings {
  public boolean canMerge(String a, String b, String c) {
    // Assumptions: a, b, c are not null.
    int alen = a.length();
    int blen = b.length();
    int clen = c.length();
    if (alen + blen != clen) {
      return false;
    }
    // a common trick is to use i to represent ith character
    // in a, the 1st character is actually a.charAt(0).
    // the benefit is we can eliminate some base cases.
    boolean[][] canMerge = new boolean[alen + 1][blen + 1];
    for (int i = 0; i <= alen; i++) {
      for (int j = 0; j <= blen; j++) {
        // this is the only base case we need to take care.
        if (i == 0 && j == 0) {
          canMerge[i][j] = true;
        }
        // two possible ways of matching the character in c.
        if (i > 0 && a.charAt(i - 1) == c.charAt(i + j - 1)) {
          canMerge[i][j] |= canMerge[i - 1][j];
        }
        if (j > 0 && b.charAt(j - 1) == c.charAt(i + j - 1)) {
          canMerge[i][j] |= canMerge[i][j - 1];
        }
      }
    }
    return canMerge[alen][blen];
  }
}

Back To Index

Class 28 - 加强练习 VII
Longest Common Substring
public class LongestCommonSubstring {
  public String longestCommon(String s, String t) {
    // Assumptions: s, t are not null.
    char[] sa = s.toCharArray();
    char[] ta = t.toCharArray();

    // record the longest common substring's start position in s.
    int start = 0;
    // record the longest common substring's length.
    int longest = 0;
    int[][] common = new int[sa.length][ta.length];
    for (int i = 0; i < sa.length; i++) {
      for (int j = 0; j < ta.length; j++) {
        if (sa[i] == ta[j]) {
          if (i == 0 || j == 0) {
            common[i][j] = 1;
          } else {
            common[i][j] = common[i - 1][j - 1] + 1;
          }
          if (common[i][j] > longest) {
            longest = common[i][j];
            start = i - longest + 1;
          }
        }
      }
    }
    return s.substring(start, start + longest);
  }
}

Longest Common Subsequence
public class LongestCommonSubSequence {
  public int longest(String s, String t) {
    // Assumptions: s, t are not null.
    // using the trick of "add 1" index, will make the base case
    // easier to handle, e.g. the 0th row and the 0th column will
    // be all zero.
    int[][] longest = new int[s.length() + 1][t.length() + 1];
    for (int i = 1; i <= s.length(); i++) {
      for (int j = 1; j <= t.length(); j++) {
        if (s.charAt(i - 1) == t.charAt(j - 1)) {
          longest[i][j] = longest[i - 1][j - 1] + 1;
        } else {
          longest[i][j] = Math.max(longest[i - 1][j], longest[i][j - 1]);
        }
      }
    }
    return longest[s.length()][t.length()];
  }
}

Longest Ascending Subsequence
public class LongestAscendingSubSequence {
  // Method 1: O(n^2).
  public int longest(int[] array) {
    // Assumptions: array is not null.
    if (array.length == 0) {
      return 0;
    }
    // dp[i] = the length of longest ascending subsequence
    // ending at index i.
    int[] longest = new int[array.length];
    // record the length of longest subsequence so far.
    int result = 1;
    for (int i = 0; i < array.length; i++) {
      // initialize dp[i] as 1, since the shortest one has length 1,
      // (just array[i] itself).
      longest[i] = 1;
      for (int j = 0; j < i; j++) {
        // only when array[j] < array[i], it is possible to use the
        // longest ascending subsequence ending at index j and array[i]
        // to form a new ascending subsequence.
        if (array[j] < array[i]) {
          longest[i] = Math.max(longest[j] + 1, longest[i]);
        }
      }
      // possibly update the global longest one.
      result = Math.max(longest[i], result);
    }
    return result;
  }

  // Method 2: O(nlogn).
  public int longestII(int[] array) {
    if (array.length == 0) {
      return 0;
    }
    // tbl[i]: the smallest ending value of all the ascending subsequences
    // with length i.
    int[] tbl = new int[array.length + 1];
    // at the very beginning, the longest ascending subsequence we have
    // has length 1(array[0] itself).
    int result = 1;
    // initialization: at the very beginning, we have a length 1 ascending
    // subsequence, ending value as array[0].
    // while we traversing the array, we will update existing tbl[i] and
    // find new longer ascending subsequence.
    tbl[1] = array[0];
    for (int i = 1; i < array.length; i++) {
      // tbl is guaranteed to be in ascending order - the key point.
      // from tbl, find the best(longest) ascending subsequence, which can
      // concatenate array[i] to form a new one.
      // this is actually a binary search of the "largest smaller value".
      int index = find(tbl, 1, result, array[i]);
      // two cases:
      // 1. we can possibly form a longer ascending subsequence than
      // whatever we have before, if array[i] is larger than all values in tbl.
      // 2. we may update tbl[index + 1] because we find a better ascending
      // subsequence with length index + 1(the ending value is smaller or
      // equal).
      if (index == result) {
        tbl[++result] = array[i];
      } else {
        tbl[index + 1] = array[i];
      }
    }
    return result;
  }

  // find the index of the "largest smaller value" to target in the tbl,
  // tbl is sorted in ascending order.
  private int find(int[] tbl, int left, int right, int target) {
    while (left <= right) {
      int mid = left + (right - left) / 2;
      if (tbl[mid] >= target) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
    return right;
  }
}

Most Points On A Line
public class MostPointsOnLine {
  public int most(Point[] points) {
    // Assumptions: points is not null, and points.length >= 2.
    // record the maximum number of points on the same line.
    int result = 0;
    // we use each pair of points to form a line.
    for (int i = 0; i < points.length; i++) {
      // any line can be represented by a point and a slope.
      // we take the point as seed and try to find all possible slopes.
      Point seed = points[i];
      // record the points with same <x,y>.
      int same = 1;
      // record the points with same x, for the special case of
      // infinite slope.
      int sameX = 0;
      // record the maximum number of points on the same line
      // crossing the seed point.
      int most = 0;
      // a map with all possible slopes.
      HashMap<Double, Integer> cnt = new HashMap<Double, Integer>();
      for (int j = 0; j < points.length; j++) {
        if (i == j) {
          continue;
        }
        Point tmp = points[j];
        if (tmp.x == seed.x && tmp.y == seed.y) {
          // handle the points with same <x,y>.
          same++;
        } else if (tmp.x == seed.x) {
          // handle the points with same x.
          sameX++;
        } else {
          // otherwise, just calculate the slope and increment the counter
          // for the calculated slope.
          double slope = ((tmp.y - seed.y) + 0.0) / (tmp.x - seed.x);
          if (!cnt.containsKey(slope)) {
            cnt.put(slope, 1);
          } else {
            cnt.put(slope, cnt.get(slope) + 1);
          }
          most = Math.max(most, cnt.get(slope));
        }
      }
      most = Math.max(most, sameX) + same;
      result = Math.max(result, most);
    }
    return result;
  }
}

Largest Set Of Points With Positive Slopes
public class LargestSetPointsPositiveSlope {
  public int largest(Point[] points) {
    // Assumptions: points is not null.
    // we need to sort the points first by y then by x.
    Arrays.sort(points, new MyComparator());
    // similar to longest ascending subsequence.
    int result = 0;
    int[] longest = new int[points.length];
    for (int i = 0; i < longest.length; i++) {
      for (int j = 0; j < i; j++) {
        if (points[j].x < points[i].x && points[j].y < points[i].y) {
          longest[i] = Math.max(longest[i], longest[j]);
        }
      }
      longest[i]++;
      result = Math.max(result, longest[i]);
    }
    return result == 1 ? 0 : result;
  }

  // this comparator will sort the points by y first then by x.
  static class MyComparator implements Comparator<Point> {
    @Override
    public int compare(Point p1, Point p2) {
      if (p1.y < p2.y) {
        return -1;
      } else if (p1.y > p2.y) {
        return 1;
      } else if (p1.x < p2.x) {
        return -1;
      } else if (p1.x > p2.x) {
        return 1;
      }
      return 0;
    }
  }
}

Generate Random Maze
public class GenerateRandomMaze {
  public int[][] maze(int n) {
    // Assumptions: n = 2 * k + 1, where k > = 0.
    int[][] maze = new int[n][n];
    // initialize the matrix as only (0,0) is corridor,
    // other cells are all walls at the beginning.
    // later we are trying to break the walls to form corridors.
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        if (i == 0 && j == 0) {
          maze[i][j] = 0;
        } else {
          maze[i][j] = 1;
        }
      }
    }
    generate(maze, 0, 0);
    return maze;
  }

  private void generate(int[][] maze, int x, int y) {
    // get a random shuffle of all the possible directions,
    // and follow the shuffled order to do DFS & backtrack.
    Dir[] dirs = Dir.values();
    shuffle(dirs);
    for (Dir dir : dirs) {
      // advance by two steps.
      int nextX = dir.moveX(x, 2);
      int nextY = dir.moveY(y, 2);
      if (isValidWall(maze, nextX, nextY)) {
        // only if the cell is a wall(meaning we have not visited before),
        // we break the walls through to make it corridors.
        maze[dir.moveX(x, 1)][dir.moveY(y, 1)] = 0;
        maze[nextX][nextY] = 0;
        generate(maze, nextX, nextY);
      }
    }
  }

  // Get a random order of the directions.
  private void shuffle(Dir[] dirs) {
    for (int i = 0; i < dirs.length; i++) {
      int index = (int) (Math.random() * (dirs.length - i));
      Dir tmp = dirs[i];
      dirs[i] = dirs[i + index];
      dirs[i + index] = tmp;
    }
  }

  // check if the position (x,y) is within the maze and it is a wall.
  private boolean isValidWall(int[][] maze, int x, int y) {
    return x >= 0 && x < maze.length && y >= 0 && y < maze[0].length && maze[x][y] == 1;
  }

  // this is an example of using enum in Java,
  // basically enum is good and recommended way for representing
  // a set of predefined constants.
  // for more details, please refer to the lab class :)
  enum Dir {
    NORTH(-1, 0), SOUTH(1, 0), EAST(0, -1), WEST(0, 1);

    int deltaX;
    int deltaY;

    Dir(int deltaX, int deltaY) {
      this.deltaX = deltaX;
      this.deltaY = deltaY;
    }

    // move certain times of deltax.
    public int moveX(int x, int times) {
      return x + times * deltaX;
    }

    // move certain times of deltay.
    public int moveY(int y, int times) {
      return y + times * deltaY;
    }
  }
}

Back To Index

Class 99

Get Count Array
public class Solution {
  public int[] countArray(int[] array) {
    // The indexArray contains the indices in the original array,
    // and it will be sorted by the corresponding number in the
    // original array.
    // The countArray is the actual return array.
    // The helper array is to help the merge sort.
    int[] indexArray = initialIndexArray(array);
    int[] countArray = new int[array.length];
    int[] helper = new int[array.length];
    mergeSort(array, indexArray, countArray, helper, 0, array.length - 1);
    return countArray;
  }
  
  // The indices are just 0 - (array.length - 1)
  private int[] initialIndexArray(int[] array) {
    int[] indices = new int[array.length];
    for (int i = 0; i < array.length; i++) {
      indices[i] = i;
    }
    return indices;
  }
  
  private void mergeSort(int[] array, int[] indexArray, int[] countArray, int[] helper, int left, int right) {
    if (left >= right) {
      return;
    }
    int mid = left + (right - left) / 2;
    mergeSort(array, indexArray, countArray, helper, left, mid);
    mergeSort(array, indexArray, countArray, helper, mid + 1, right);
    merge(array, indexArray, countArray, helper, left, mid, right);
  }
  
  private void merge(int[] array, int[] indexArray, int[] countArray, int[] helper, int left, int mid, int right) {
    copyArray(indexArray, helper, left, right);
    int l = left;
    int r = mid + 1;
    int cur = left;
    while (l <= mid) {
      // When sorting the indexArray, we use the corresponding value in the 
      // original array.
      if (r > right || array[helper[l]] <= array[helper[r]]) {
        countArray[helper[l]] += (r - mid - 1);
        indexArray[cur++] = helper[l++];
      } else {
        indexArray[cur++] = helper[r++];
      }
    }
  }
  
  private void copyArray(int[] indexArray, int[] helper, int left, int right) {
    for (int i = left; i <= right; i++) {
      helper[i] = indexArray[i];
    }
  }
}

Largest Sum Of Valid Numbers
// NOTICE:
// You do not need to master this problem, Since it is a relatively hard one.
// This solution is only for those who are interested.
// Writeup for the solution:
// 1. Think about one way of how to observe the matrix:
//    take each row as a single element, the matrix is
//    actually an array of rows. The benefit of doing so
//    is to convert a two dimensional space problem into
//    a one dimensional space problem
// 2. How do you represent each row? More accurately,
//    we want to know for each row, what are all possible
//    ways of choosing some numbers from the row. we call
//    each of the ways is a "configuration". e.g.
//    we can choose index of 0,3,5,7 as one configuration,
//    or choose index of 1,6, etc...
// 3. The problem is simply converted to:
//    There are 8 configurations in the array, and each
//    pair of adjacent configurations c1 and c2 need to
//    maintain certain property: if index i is picked in
//    c1, then c1,c1-1,c1+1 can not be picked in c2.
// 4. We need a efficient way for the representation of
//    each of the "configurations", essentially what we need
//    is just 8 bit, each bit means if the corresponding index
//    is picked in the configuration or not.
public class LargestSumOfValidNumbers {
  public int largestSum(int[][] matrix) {
    // Assumptions: matrix is not null, 8 * 8
    int k = 8;
    // Get all the possible configurations, each configuration is
    // represented by an int value, and we use the lowest 8 bit
    // to know which indices has been picked.
    // Here we guarantee that no adjacent bit is been picked in
    // any of the configurations.
    List<Integer> configs = validConfigs(k);
    // dp[i][j] = the max possible sum for the submatrix of row 0 - i
    // and row i pick the jth configuration.
    int[][] largest = new int[k][configs.size()];
    for (int i = 0; i < k; i++) {
      // dp[i][j] = max(dp[i - 1][k]) for all possible configuration k
      // that does not have conflict with configuration j.
      for (int j = 0; j < configs.size(); j++) {
        largest[i][j] = Integer.MIN_VALUE;
        if (i == 0) {
          largest[i][j] = sum(matrix[i], configs.get(j));
        } else {
          for (int l = 0; l < configs.size(); l++) {
            if (noConflict(configs.get(j), configs.get(l))) {
              largest[i][j] = Math.max(largest[i][j], largest[i - 1][l] + sum(matrix[i], configs.get(j)));
            }
          }
        }
      }
    }
    // the result is max(dp[7][k]) for all possible configuration k.
    int result = largest[k - 1][0];
    for (int i = 1; i < configs.size(); i++) {
      result = Math.max(result, largest[k - 1][i]);
    }
    return result;
  }

  // get all possible configurations, each one is represented as an int value,
  // and we use the lowest 8 bits.
  // we guarantee no adjacent bit is chosen for the lowest 8 bits.
  private List<Integer> validConfigs(int k) {
    List<Integer> configs = new ArrayList<Integer>();
    helper(configs, 0, k, 0);
    return configs;
  }

  // similar to subset problem.
  private void helper(List<Integer> configs, int index, int k, int cur) {
    configs.add(cur);
    for (int i = index; i < k; i++) {
      helper(configs, i + 2, k, cur | (1 << i));
    }
  }

  // trick to check if configuration c1 and configuration c2 has any conflict.
  // By conflict, it means if ith bit is 1 in c1, then ith,(i-1)th,(i+1)th bit
  // can not be 1 in c2.
  private boolean noConflict(int c1, int c2) {
    return (c1 & c2) == 0 && ((c1 << 1) & c2) == 0 && (c1 & (c2 << 1)) == 0;
  }

  // use the configuration to calculate the real sum.
  private int sum(int[] array, int config) {
    int sum = 0;
    for (int i = 0; i < array.length; i++) {
      if (((config >>> i) & 1) != 0) {
        sum += array[i];
      }
    }
    return sum;
  }
}

